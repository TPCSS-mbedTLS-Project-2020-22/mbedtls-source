{"message":"`main` function not found in crate `asn1_parse`","code":{"code":"E0601","explanation":"No `main` function was found in a binary crate.\n\nTo fix this error, add a `main` function:\n\n```\nfn main() {\n    // Your program will start here.\n    println!(\"Hello world!\");\n}\n```\n\nIf you don't know the basics of Rust, you can look at the\n[Rust Book][rust-book] to get started.\n\n[rust-book]: https://doc.rust-lang.org/book/\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":32011,"line_start":1,"line_end":952,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"#[cfg(feature = \"BIGNUM\")]","highlight_start":1,"highlight_end":27},{"text":"use super::bignum;","highlight_start":1,"highlight_end":19},{"text":"use std::mem;","highlight_start":1,"highlight_end":14},{"text":"///","highlight_start":1,"highlight_end":4},{"text":"/// \\name ASN1 Error codes","highlight_start":1,"highlight_end":27},{"text":"/// These error codes are OR'ed to X509 error codes for","highlight_start":1,"highlight_end":56},{"text":"/// higher error granularity.","highlight_start":1,"highlight_end":30},{"text":"/// ASN1 is a standard to specify data structures.","highlight_start":1,"highlight_end":51},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// Out of data when parsing an ASN1 data structure.","highlight_start":1,"highlight_end":53},{"text":"pub const ERR_OUT_OF_DATA     : i32 = -0x0060;","highlight_start":1,"highlight_end":47},{"text":"/// ASN1 tag was of an unexpected value.","highlight_start":1,"highlight_end":41},{"text":"pub const ERR_UNEXPECTED_TAG  : i32 = -0x0062;","highlight_start":1,"highlight_end":47},{"text":"/// Error when trying to determine the length or invalid length.","highlight_start":1,"highlight_end":65},{"text":"pub const ERR_INVALID_LENGTH  : i32 = -0x0064;","highlight_start":1,"highlight_end":47},{"text":"/// Actual length differs from expected length.","highlight_start":1,"highlight_end":48},{"text":"pub const ERR_LENGTH_MISMATCH : i32 = -0x0066;","highlight_start":1,"highlight_end":47},{"text":"/// Data is invalid.","highlight_start":1,"highlight_end":21},{"text":"pub const ERR_INVALID_DATA    : i32 = -0x0068;","highlight_start":1,"highlight_end":47},{"text":"/// Memory allocation failed","highlight_start":1,"highlight_end":29},{"text":"pub const ERR_ALLOC_FAILED    : i32 = -0x006A;","highlight_start":1,"highlight_end":47},{"text":"/// Buffer too small when writing ASN.1 data structure.","highlight_start":1,"highlight_end":56},{"text":"pub const ERR_BUF_TOO_SMALL   : i32 = -0x006C;","highlight_start":1,"highlight_end":47},{"text":"pub const ERROR_CORRUPTION_DETECTED : i32 = -0x006E;","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"///","highlight_start":1,"highlight_end":4},{"text":"/// DER constants","highlight_start":1,"highlight_end":18},{"text":"/// These constants comply with the DER encoded ASN.1 type tags.","highlight_start":1,"highlight_end":65},{"text":"/// DER encoding uses hexadecimal representation.","highlight_start":1,"highlight_end":50},{"text":"/// An example DER sequence is:\\n","highlight_start":1,"highlight_end":34},{"text":"/// - 0x02 -- tag indicating INTEGER","highlight_start":1,"highlight_end":37},{"text":"/// - 0x01 -- length in octets","highlight_start":1,"highlight_end":31},{"text":"/// - 0x05 -- value","highlight_start":1,"highlight_end":20},{"text":"/// Such sequences are typically read into \\c ::mbedtls_x509_buf.","highlight_start":1,"highlight_end":66},{"text":"///","highlight_start":1,"highlight_end":4},{"text":"","highlight_start":1,"highlight_end":1},{"text":"pub const BOOLEAN          : u8 = 0x01;","highlight_start":1,"highlight_end":40},{"text":"pub const INTEGER          : u8 = 0x02;","highlight_start":1,"highlight_end":40},{"text":"pub const BIT_STRING       : u8 = 0x03;","highlight_start":1,"highlight_end":40},{"text":"pub const OCTET_STRING     : u8 = 0x04;","highlight_start":1,"highlight_end":40},{"text":"pub const NULL             : u8 = 0x05;","highlight_start":1,"highlight_end":40},{"text":"pub const OID              : u8 = 0x06;","highlight_start":1,"highlight_end":40},{"text":"pub const ENUMERATED       : u8 = 0x0A;","highlight_start":1,"highlight_end":40},{"text":"pub const UTF8_STRING      : u8 = 0x0C;","highlight_start":1,"highlight_end":40},{"text":"pub const SEQUENCE         : u8 = 0x10;","highlight_start":1,"highlight_end":40},{"text":"pub const SET              : u8 = 0x11;","highlight_start":1,"highlight_end":40},{"text":"pub const PRINTABLE_STRING : u8 = 0x13;","highlight_start":1,"highlight_end":40},{"text":"pub const T61_STRING       : u8 = 0x14;","highlight_start":1,"highlight_end":40},{"text":"pub const IA5_STRING       : u8 = 0x16;","highlight_start":1,"highlight_end":40},{"text":"pub const UTC_TIME         : u8 = 0x17;","highlight_start":1,"highlight_end":40},{"text":"pub const GENERALIZED_TIME : u8 = 0x18;","highlight_start":1,"highlight_end":40},{"text":"pub const UNIVERSAL_STRING : u8 = 0x1C;","highlight_start":1,"highlight_end":40},{"text":"pub const BMP_STRING       : u8 = 0x1E;","highlight_start":1,"highlight_end":40},{"text":"pub const PRIMITIVE        : u8 = 0x00;","highlight_start":1,"highlight_end":40},{"text":"pub const CONSTRUCTED      : u8 = 0x20;","highlight_start":1,"highlight_end":40},{"text":"pub const CONTEXT_SPECIFIC : u8 = 0x80;","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"///","highlight_start":1,"highlight_end":4},{"text":"/// Bit masks for each of the components of an ASN.1 tag as specified in","highlight_start":1,"highlight_end":73},{"text":"/// ITU X.690 (08/2015), section 8.1 \"General rules for encoding\",","highlight_start":1,"highlight_end":67},{"text":"/// paragraph 8.1.2.2:","highlight_start":1,"highlight_end":23},{"text":"///","highlight_start":1,"highlight_end":4},{"text":"/// Bit  8     7   6   5          1","highlight_start":1,"highlight_end":36},{"text":"///     +-------+-----+------------+","highlight_start":1,"highlight_end":37},{"text":"///     | Class | P/C | Tag number |","highlight_start":1,"highlight_end":37},{"text":"///     +-------+-----+------------+","highlight_start":1,"highlight_end":37},{"text":"///","highlight_start":1,"highlight_end":4},{"text":"pub const TAG_CLASS_MASK : u8 = 0xC0;","highlight_start":1,"highlight_end":38},{"text":"pub const TAG_PC_MASK    : u8 = 0x20;","highlight_start":1,"highlight_end":38},{"text":"pub const TAG_VALUE_MASK : u8 = 0x1F;","highlight_start":1,"highlight_end":38},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// Functions to parse ASN.1 data structures","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// Type-length-value structure that allows for ASN1 using DER.","highlight_start":1,"highlight_end":64},{"text":"pub struct Buf{","highlight_start":1,"highlight_end":16},{"text":"    /// ASN1 type, e.g. MBEDTLS_ASN1_UTF8_STRING.","highlight_start":1,"highlight_end":50},{"text":"    tag: i32,","highlight_start":1,"highlight_end":14},{"text":"    /// ASN1 length, in octets.","highlight_start":1,"highlight_end":32},{"text":"    len: usize,","highlight_start":1,"highlight_end":16},{"text":"    /// ASN1 data, e.g. in ASCII.","highlight_start":1,"highlight_end":34},{"text":"    p: Vec<u8>,","highlight_start":1,"highlight_end":16},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// Container for ASN1 bit strings.","highlight_start":1,"highlight_end":36},{"text":"pub struct BitString{","highlight_start":1,"highlight_end":22},{"text":"    /// ASN1 length, in octets.","highlight_start":1,"highlight_end":32},{"text":"    len: usize,","highlight_start":1,"highlight_end":16},{"text":"    /// Number of unused bits at the end of the string","highlight_start":1,"highlight_end":55},{"text":"    unused_bits: u8,","highlight_start":1,"highlight_end":21},{"text":"    /// Raw ASN1 data for the bit string","highlight_start":1,"highlight_end":41},{"text":"    p: Vec<u8>,","highlight_start":1,"highlight_end":16},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// Container for a sequence of ASN.1 items","highlight_start":1,"highlight_end":44},{"text":"pub struct Sequence{","highlight_start":1,"highlight_end":21},{"text":"    /// Buffer containing the given ASN.1 item.","highlight_start":1,"highlight_end":48},{"text":"    pub buf: Buf,","highlight_start":1,"highlight_end":18},{"text":"    /// The next entry in the sequence.","highlight_start":1,"highlight_end":40},{"text":"    pub next: Option<Box<Sequence>>,","highlight_start":1,"highlight_end":37},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl Sequence{","highlight_start":1,"highlight_end":15},{"text":"    fn new() -> Box<Sequence> {","highlight_start":1,"highlight_end":32},{"text":"        return Box::new(Sequence{","highlight_start":1,"highlight_end":34},{"text":"            buf : Buf{","highlight_start":1,"highlight_end":23},{"text":"                tag: 0,","highlight_start":1,"highlight_end":24},{"text":"                len: 0,","highlight_start":1,"highlight_end":24},{"text":"                p: Vec::new(),","highlight_start":1,"highlight_end":31},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"            next : None,","highlight_start":1,"highlight_end":25},{"text":"        });","highlight_start":1,"highlight_end":12},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// Container for a sequence or list of 'named' ASN.1 data items","highlight_start":1,"highlight_end":65},{"text":"pub struct NamedData {","highlight_start":1,"highlight_end":23},{"text":"    /// The object identifier.","highlight_start":1,"highlight_end":31},{"text":"    oid: Buf,","highlight_start":1,"highlight_end":14},{"text":"    /// The named value.","highlight_start":1,"highlight_end":25},{"text":"    val: Buf,","highlight_start":1,"highlight_end":14},{"text":"    /// The next entry in the sequence.","highlight_start":1,"highlight_end":40},{"text":"    next: Option<Box<NamedData>>,","highlight_start":1,"highlight_end":34},{"text":"    /// Merge next item into the current one?","highlight_start":1,"highlight_end":46},{"text":"    next_merged: u8,","highlight_start":1,"highlight_end":21},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// Structure used as a workaround for `unsigned char **p` in C.","highlight_start":1,"highlight_end":65},{"text":"///","highlight_start":1,"highlight_end":4},{"text":"/// In other words this buffer can be used in cases where callee might want to skip some ","highlight_start":1,"highlight_end":90},{"text":"/// bytes from front and subsequent callee continues to read from where last callee ended.","highlight_start":1,"highlight_end":91},{"text":"struct SkipBuffer{","highlight_start":1,"highlight_end":19},{"text":"    /// Buffer holding data","highlight_start":1,"highlight_end":28},{"text":"    buf: Vec<u8>,","highlight_start":1,"highlight_end":18},{"text":"    /// index for keeping track of location to be read","highlight_start":1,"highlight_end":55},{"text":"    ptr: usize,","highlight_start":1,"highlight_end":16},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"///","highlight_start":1,"highlight_end":4},{"text":"/// \\brief       Get the length of an ASN.1 element.","highlight_start":1,"highlight_end":53},{"text":"///              Updates the pointer to immediately behind the length.","highlight_start":1,"highlight_end":71},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\param p     On entry, \\c *p points to the first byte of the length,","highlight_start":1,"highlight_end":73},{"text":"///              i.e. immediately after the tag.","highlight_start":1,"highlight_end":49},{"text":"///              On successful completion, \\c *p points to the first byte","highlight_start":1,"highlight_end":74},{"text":"///              after the length, i.e. the first byte of the content.","highlight_start":1,"highlight_end":71},{"text":"///              On error, the value of \\c *p is undefined.","highlight_start":1,"highlight_end":60},{"text":"/// \\param end   End of data.","highlight_start":1,"highlight_end":30},{"text":"/// \\param len   On successful completion, \\c *len contains the length","highlight_start":1,"highlight_end":71},{"text":"///              read from the ASN.1 input.","highlight_start":1,"highlight_end":44},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\return      0 if successful.","highlight_start":1,"highlight_end":34},{"text":"/// \\return      #MBEDTLS_ERR_ASN1_OUT_OF_DATA if the ASN.1 element","highlight_start":1,"highlight_end":68},{"text":"///              would end beyond \\p end.","highlight_start":1,"highlight_end":42},{"text":"/// \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the length is unparseable.","highlight_start":1,"highlight_end":80},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"fn get_len(p: &mut SkipBuffer, end: usize, len: &mut usize) -> i32 {","highlight_start":1,"highlight_end":69},{"text":"    if (end - p.ptr) < 1{","highlight_start":1,"highlight_end":26},{"text":"       return ERR_OUT_OF_DATA;","highlight_start":1,"highlight_end":31},{"text":"   }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"   if (p.buf[p.ptr] & 0x80) == 0{","highlight_start":1,"highlight_end":34},{"text":"       p.ptr = p.ptr + 1;","highlight_start":1,"highlight_end":26},{"text":"       *len = p.buf[p.ptr] as usize ;","highlight_start":1,"highlight_end":38},{"text":"   } ","highlight_start":1,"highlight_end":6},{"text":"   else {","highlight_start":1,"highlight_end":10},{"text":"       let mut number = p.buf[p.ptr] & 0x7F;","highlight_start":1,"highlight_end":45},{"text":"       match number{ ","highlight_start":1,"highlight_end":22},{"text":"         1 => {","highlight_start":1,"highlight_end":16},{"text":"             if (end - p.ptr) < 2{","highlight_start":1,"highlight_end":35},{"text":"             return ERR_OUT_OF_DATA;","highlight_start":1,"highlight_end":37},{"text":"             } ","highlight_start":1,"highlight_end":16},{"text":"             *len = p.buf[p.ptr + 1] as usize;","highlight_start":1,"highlight_end":47},{"text":"             p.ptr = p.ptr + 2;","highlight_start":1,"highlight_end":32},{"text":"           },","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"         2 => {","highlight_start":1,"highlight_end":16},{"text":"              if (end - p.ptr) < 3{","highlight_start":1,"highlight_end":36},{"text":"              return ERR_OUT_OF_DATA;","highlight_start":1,"highlight_end":38},{"text":"              }","highlight_start":1,"highlight_end":16},{"text":"              *len = (p.buf[p.ptr + 1] << 8 as usize | p.buf[p.ptr + 2]) as usize ;","highlight_start":1,"highlight_end":84},{"text":"              p.ptr = p.ptr + 3;","highlight_start":1,"highlight_end":33},{"text":"           },","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"         3 => {","highlight_start":1,"highlight_end":16},{"text":"             if (end - p.ptr) < 4{","highlight_start":1,"highlight_end":35},{"text":"               return ERR_OUT_OF_DATA;","highlight_start":1,"highlight_end":39},{"text":"             }","highlight_start":1,"highlight_end":15},{"text":"             *len = (p.buf[p.ptr + 1] << 16 as usize | p.buf[p.ptr + 2] << 8 as usize| p.buf[p.ptr + 3]) as usize;","highlight_start":1,"highlight_end":115},{"text":"             p.ptr = p.ptr + 4;","highlight_start":1,"highlight_end":32},{"text":"            ","highlight_start":1,"highlight_end":13},{"text":"           },","highlight_start":1,"highlight_end":14},{"text":"         ","highlight_start":1,"highlight_end":10},{"text":"         4 => {","highlight_start":1,"highlight_end":16},{"text":"             if (end - p.ptr ) < 5{","highlight_start":1,"highlight_end":36},{"text":"             return ERR_OUT_OF_DATA;","highlight_start":1,"highlight_end":37},{"text":"             }","highlight_start":1,"highlight_end":15},{"text":"             *len = (p.buf[p.ptr + 1] << 24 as usize| p.buf[p.ptr + 2] << 16 as usize | p.buf[p.ptr + 3] << 8 as usize | p.buf[p.ptr + 4]) as usize;","highlight_start":1,"highlight_end":149},{"text":"             p.ptr = p.ptr + 5;","highlight_start":1,"highlight_end":32},{"text":"              ","highlight_start":1,"highlight_end":15},{"text":"","highlight_start":1,"highlight_end":1},{"text":"           },","highlight_start":1,"highlight_end":14},{"text":"         ","highlight_start":1,"highlight_end":10},{"text":"           _ => {","highlight_start":1,"highlight_end":18},{"text":"               return ERR_INVALID_LENGTH; ","highlight_start":1,"highlight_end":43},{"text":"           } ,","highlight_start":1,"highlight_end":15},{"text":"       };","highlight_start":1,"highlight_end":10},{"text":"   }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"   if *len > (end - p.ptr) as usize{","highlight_start":1,"highlight_end":37},{"text":"       return ERR_OUT_OF_DATA;","highlight_start":1,"highlight_end":31},{"text":"   }","highlight_start":1,"highlight_end":5},{"text":"   return 0;","highlight_start":1,"highlight_end":13},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\brief       Get the tag and length of the element.","highlight_start":1,"highlight_end":56},{"text":"///              Check for the requested tag.","highlight_start":1,"highlight_end":46},{"text":"///              Updates the pointer to immediately behind the tag and length.","highlight_start":1,"highlight_end":79},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\param p     On entry, \\c *p points to the start of the ASN.1 element.","highlight_start":1,"highlight_end":75},{"text":"///              On successful completion, \\c *p points to the first byte","highlight_start":1,"highlight_end":74},{"text":"///              after the length, i.e. the first byte of the content.","highlight_start":1,"highlight_end":71},{"text":"///              On error, the value of \\c *p is undefined.","highlight_start":1,"highlight_end":60},{"text":"/// \\param end   End of data.","highlight_start":1,"highlight_end":30},{"text":"/// \\param len   On successful completion, \\c *len contains the length","highlight_start":1,"highlight_end":71},{"text":"///              read from the ASN.1 input.","highlight_start":1,"highlight_end":44},{"text":"/// \\param tag   The expected tag.","highlight_start":1,"highlight_end":35},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\return      0 if successful.","highlight_start":1,"highlight_end":34},{"text":"/// \\return      #MBEDTLS_ERR_ASN1_UNEXPECTED_TAG if the data does not start","highlight_start":1,"highlight_end":77},{"text":"///              with the requested tag.","highlight_start":1,"highlight_end":41},{"text":"/// \\return      #MBEDTLS_ERR_ASN1_OUT_OF_DATA if the ASN.1 element","highlight_start":1,"highlight_end":68},{"text":"///              would end beyond \\p end.","highlight_start":1,"highlight_end":42},{"text":"/// \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the length is unparseable.","highlight_start":1,"highlight_end":80},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"fn get_tag(p: &mut SkipBuffer, end: usize, len: &mut usize, tag: i32) -> i32 {","highlight_start":1,"highlight_end":79},{"text":"    if (end - p.ptr) < 1{","highlight_start":1,"highlight_end":26},{"text":"        return ERR_OUT_OF_DATA;","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    if p.buf[p.ptr] != tag as u8{","highlight_start":1,"highlight_end":34},{"text":"        return ERR_UNEXPECTED_TAG;","highlight_start":1,"highlight_end":35},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    p.ptr = p.ptr + 1;","highlight_start":1,"highlight_end":23},{"text":"    return get_len( p, end, len);","highlight_start":1,"highlight_end":34},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\brief       Retrieve a boolean ASN.1 tag and its value.","highlight_start":1,"highlight_end":61},{"text":"///              Updates the pointer to immediately behind the full tag.","highlight_start":1,"highlight_end":73},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\param p     On entry, \\c *p points to the start of the ASN.1 element.","highlight_start":1,"highlight_end":75},{"text":"///              On successful completion, \\c *p points to the first byte","highlight_start":1,"highlight_end":74},{"text":"///              beyond the ASN.1 element.","highlight_start":1,"highlight_end":43},{"text":"///              On error, the value of \\c *p is undefined.","highlight_start":1,"highlight_end":60},{"text":"/// \\param end   End of data.","highlight_start":1,"highlight_end":30},{"text":"/// \\param val   On success, the parsed value (\\c 0 or \\c 1).","highlight_start":1,"highlight_end":62},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\return      0 if successful.","highlight_start":1,"highlight_end":34},{"text":"/// \\return      An ASN.1 error code if the input does not start with","highlight_start":1,"highlight_end":70},{"text":"///              a valid ASN.1 BOOLEAN.","highlight_start":1,"highlight_end":40},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"fn get_bool(p: &mut SkipBuffer, end: usize, val: &mut i32) -> i32 {","highlight_start":1,"highlight_end":68},{"text":"    let mut ret: i32 = ERROR_CORRUPTION_DETECTED;","highlight_start":1,"highlight_end":50},{"text":"    let mut len: usize;","highlight_start":1,"highlight_end":24},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    ret  = get_tag(p, end, &mut len, BOOLEAN as i32);","highlight_start":1,"highlight_end":54},{"text":"    if ret != 0 {","highlight_start":1,"highlight_end":18},{"text":"        return ret;","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    if len != 1{","highlight_start":1,"highlight_end":17},{"text":"        return ERR_INVALID_LENGTH;","highlight_start":1,"highlight_end":35},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    if p.buf[p.ptr] != 0{","highlight_start":1,"highlight_end":26},{"text":"        *val = 1;","highlight_start":1,"highlight_end":18},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    else{","highlight_start":1,"highlight_end":10},{"text":"        *val = 0;","highlight_start":1,"highlight_end":18},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    p.ptr = p.ptr + 1;","highlight_start":1,"highlight_end":23},{"text":"    return 0;","highlight_start":1,"highlight_end":14},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"fn get_tagged_int(p: &mut SkipBuffer, end: usize, tag:i32, val: &mut i32) -> i32 {","highlight_start":1,"highlight_end":83},{"text":"    let mut ret: i32 = ERROR_CORRUPTION_DETECTED;","highlight_start":1,"highlight_end":50},{"text":"    let mut len: usize;","highlight_start":1,"highlight_end":24},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    ret = get_tag(p, end, &mut len, tag);","highlight_start":1,"highlight_end":42},{"text":"    if ret != 0{","highlight_start":1,"highlight_end":17},{"text":"        return ret;","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /*","highlight_start":1,"highlight_end":7},{"text":"     * len==0 is malformed (0 must be represented as 020100 for INTEGER,","highlight_start":1,"highlight_end":73},{"text":"     * or 0A0100 for ENUMERATED tags","highlight_start":1,"highlight_end":37},{"text":"     */","highlight_start":1,"highlight_end":8},{"text":"    if len == 0{","highlight_start":1,"highlight_end":17},{"text":"        return ERR_INVALID_LENGTH;","highlight_start":1,"highlight_end":35},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    /* This is a cryptography library. Reject negative integers. */","highlight_start":1,"highlight_end":68},{"text":"    if (p.buf[p.ptr] as u8 & 0x80) != 0{","highlight_start":1,"highlight_end":41},{"text":"        return ERR_INVALID_LENGTH;","highlight_start":1,"highlight_end":35},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    /* Skip leading zeros. */","highlight_start":1,"highlight_end":30},{"text":"    while (len > 0) && (p.buf[p.ptr] == 0){","highlight_start":1,"highlight_end":44},{"text":"        p.ptr = p.ptr + 1;","highlight_start":1,"highlight_end":27},{"text":"        len = len - 1;","highlight_start":1,"highlight_end":23},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /* Reject integers that don't fit in an int. This code assumes that","highlight_start":1,"highlight_end":72},{"text":"     * the int type has no padding bit. */","highlight_start":1,"highlight_end":43},{"text":"    if len > mem::size_of::<i32>(){","highlight_start":1,"highlight_end":36},{"text":"        return ERR_INVALID_LENGTH;","highlight_start":1,"highlight_end":35},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    if (len == mem::size_of::<i32>()) && ((p.buf[p.ptr] as u8 & 0x80) != 0){","highlight_start":1,"highlight_end":77},{"text":"        return ERR_INVALID_LENGTH;","highlight_start":1,"highlight_end":35},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"    *val = 0;","highlight_start":1,"highlight_end":14},{"text":"    while len > 0 {","highlight_start":1,"highlight_end":20},{"text":"        len = len - 1;","highlight_start":1,"highlight_end":23},{"text":"        *val = (*val << 8) | p.buf[p.ptr] as i32;","highlight_start":1,"highlight_end":50},{"text":"        p.ptr = p.ptr + 1;","highlight_start":1,"highlight_end":27},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    return 0;    ","highlight_start":1,"highlight_end":18},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\brief       Retrieve an integer ASN.1 tag and its value.","highlight_start":1,"highlight_end":62},{"text":"///              Updates the pointer to immediately behind the full tag.","highlight_start":1,"highlight_end":73},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\param p     On entry, \\c *p points to the start of the ASN.1 element.","highlight_start":1,"highlight_end":75},{"text":"///              On successful completion, \\c *p points to the first byte","highlight_start":1,"highlight_end":74},{"text":"///              beyond the ASN.1 element.","highlight_start":1,"highlight_end":43},{"text":"///              On error, the value of \\c *p is undefined.","highlight_start":1,"highlight_end":60},{"text":"/// \\param end   End of data.","highlight_start":1,"highlight_end":30},{"text":"/// \\param val   On success, the parsed value.","highlight_start":1,"highlight_end":47},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\return      0 if successful.","highlight_start":1,"highlight_end":34},{"text":"/// \\return      An ASN.1 error code if the input does not start with","highlight_start":1,"highlight_end":70},{"text":"///              a valid ASN.1 INTEGER.","highlight_start":1,"highlight_end":40},{"text":"/// \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the parsed value does","highlight_start":1,"highlight_end":75},{"text":"///              not fit in an \\c int.","highlight_start":1,"highlight_end":39},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"fn get_int(p: &mut SkipBuffer, end: usize, val: &mut i32) -> i32{","highlight_start":1,"highlight_end":66},{"text":"    return get_tagged_int(p, end, INTEGER as i32, val);","highlight_start":1,"highlight_end":56},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\brief       Retrieve an enumerated ASN.1 tag and its value.","highlight_start":1,"highlight_end":65},{"text":"///              Updates the pointer to immediately behind the full tag.","highlight_start":1,"highlight_end":73},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\param p     On entry, \\c *p points to the start of the ASN.1 element.","highlight_start":1,"highlight_end":75},{"text":"///              On successful completion, \\c *p points to the first byte","highlight_start":1,"highlight_end":74},{"text":"///              beyond the ASN.1 element.","highlight_start":1,"highlight_end":43},{"text":"///              On error, the value of \\c *p is undefined.","highlight_start":1,"highlight_end":60},{"text":"/// \\param end   End of data.","highlight_start":1,"highlight_end":30},{"text":"/// \\param val   On success, the parsed value.","highlight_start":1,"highlight_end":47},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\return      0 if successful.","highlight_start":1,"highlight_end":34},{"text":"/// \\return      An ASN.1 error code if the input does not start with","highlight_start":1,"highlight_end":70},{"text":"///              a valid ASN.1 ENUMERATED.","highlight_start":1,"highlight_end":43},{"text":"/// \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the parsed value does","highlight_start":1,"highlight_end":75},{"text":"///              not fit in an \\c int.","highlight_start":1,"highlight_end":39},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"fn get_enum(p: &mut SkipBuffer, end: usize, val: &mut i32) -> i32 {","highlight_start":1,"highlight_end":68},{"text":"    return get_tagged_int(p, end, ENUMERATED as i32, val);","highlight_start":1,"highlight_end":59},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\brief       Retrieve a bitstring ASN.1 tag and its value.","highlight_start":1,"highlight_end":63},{"text":"///              Updates the pointer to immediately behind the full tag.","highlight_start":1,"highlight_end":73},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\param p     On entry, \\c *p points to the start of the ASN.1 element.","highlight_start":1,"highlight_end":75},{"text":"///              On successful completion, \\c *p is equal to \\p end.","highlight_start":1,"highlight_end":69},{"text":"///              On error, the value of \\c *p is undefined.","highlight_start":1,"highlight_end":60},{"text":"/// \\param end   End of data.","highlight_start":1,"highlight_end":30},{"text":"/// \\param bs    On success, ::mbedtls_asn1_bitstring information about","highlight_start":1,"highlight_end":72},{"text":"///              the parsed value.","highlight_start":1,"highlight_end":35},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\return      0 if successful.","highlight_start":1,"highlight_end":34},{"text":"/// \\return      #MBEDTLS_ERR_ASN1_LENGTH_MISMATCH if the input contains","highlight_start":1,"highlight_end":73},{"text":"///              extra data after a valid BIT STRING.","highlight_start":1,"highlight_end":54},{"text":"/// \\return      An ASN.1 error code if the input does not start with","highlight_start":1,"highlight_end":70},{"text":"///              a valid ASN.1 BIT STRING.","highlight_start":1,"highlight_end":43},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"fn get_bitstring(p: &mut SkipBuffer, end: usize, bs: &mut BitString) -> i32 {","highlight_start":1,"highlight_end":78},{"text":"    let mut ret: i32 = ERROR_CORRUPTION_DETECTED;","highlight_start":1,"highlight_end":50},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    /* Certificate type is a single byte bitstring */","highlight_start":1,"highlight_end":54},{"text":"    ret = get_tag(p, end, &mut bs.len, BIT_STRING as i32);","highlight_start":1,"highlight_end":59},{"text":"    if ret != 0{","highlight_start":1,"highlight_end":17},{"text":"        return ret;","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /* Check length, subtract one for actual bit string length */","highlight_start":1,"highlight_end":66},{"text":"    if bs.len < 1{","highlight_start":1,"highlight_end":19},{"text":"        return ERR_OUT_OF_DATA;","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    bs.len = bs.len - 1;","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /* Get number of unused bits, ensure unused bits <= 7 */","highlight_start":1,"highlight_end":61},{"text":"    bs.unused_bits = p.buf[p.ptr];","highlight_start":1,"highlight_end":35},{"text":"    if bs.unused_bits > 7{","highlight_start":1,"highlight_end":27},{"text":"        return ERR_INVALID_LENGTH; ","highlight_start":1,"highlight_end":36},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    p.ptr = p.ptr + 1;","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /* Get actual bitstring */","highlight_start":1,"highlight_end":31},{"text":"    bs.p = p.buf;","highlight_start":1,"highlight_end":18},{"text":"    p.ptr = p.ptr + bs.len;","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    if p.ptr != end {","highlight_start":1,"highlight_end":22},{"text":"        return ERR_LENGTH_MISMATCH;","highlight_start":1,"highlight_end":36},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    return 0;","highlight_start":1,"highlight_end":14},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\brief       Retrieve a bitstring ASN.1 tag without unused bits and its","highlight_start":1,"highlight_end":76},{"text":"///              value.","highlight_start":1,"highlight_end":24},{"text":"///              Updates the pointer to the beginning of the bit/octet string.","highlight_start":1,"highlight_end":79},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\param p     On entry, \\c *p points to the start of the ASN.1 element.","highlight_start":1,"highlight_end":75},{"text":"///              On successful completion, \\c *p points to the first byte","highlight_start":1,"highlight_end":74},{"text":"///              of the content of the BIT STRING.","highlight_start":1,"highlight_end":51},{"text":"///              On error, the value of \\c *p is undefined.","highlight_start":1,"highlight_end":60},{"text":"/// \\param end   End of data.","highlight_start":1,"highlight_end":30},{"text":"/// \\param len   On success, \\c *len is the length of the content in bytes.","highlight_start":1,"highlight_end":76},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\return      0 if successful.","highlight_start":1,"highlight_end":34},{"text":"/// \\return      #MBEDTLS_ERR_ASN1_INVALID_DATA if the input starts with","highlight_start":1,"highlight_end":73},{"text":"///              a valid BIT STRING with a nonzero number of unused bits.","highlight_start":1,"highlight_end":74},{"text":"/// \\return      An ASN.1 error code if the input does not start with","highlight_start":1,"highlight_end":70},{"text":"///              a valid ASN.1 BIT STRING.","highlight_start":1,"highlight_end":43},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"fn get_bitstring_null(p: &mut SkipBuffer, end: usize, len: &mut usize) -> i32 {","highlight_start":1,"highlight_end":80},{"text":"    let mut ret: i32 =ERROR_CORRUPTION_DETECTED;","highlight_start":1,"highlight_end":49},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    ret = get_tag(p, end, len, BIT_STRING as i32);","highlight_start":1,"highlight_end":51},{"text":"    if ret != 0 {","highlight_start":1,"highlight_end":18},{"text":"        return ret;","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    if *len == 0{","highlight_start":1,"highlight_end":18},{"text":"        return ERR_INVALID_DATA;","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    *len = *len - 1;","highlight_start":1,"highlight_end":21},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    if p.buf[p.ptr] != 0 {","highlight_start":1,"highlight_end":27},{"text":"        return ERR_INVALID_DATA;","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    p.ptr = p.ptr + 1;","highlight_start":1,"highlight_end":23},{"text":"    return 0;","highlight_start":1,"highlight_end":14},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"pub struct SequenceOfCbCtxT{","highlight_start":1,"highlight_end":29},{"text":"    tag: i32,","highlight_start":1,"highlight_end":14},{"text":"    cur: Sequence","highlight_start":1,"highlight_end":18},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"fn get_sequence_of_cb(ctx: &mut SequenceOfCbCtxT, tag: i32, start: &mut Vec<u8>, len: usize) -> i32{","highlight_start":1,"highlight_end":101},{"text":"    let cb_ctx: &mut SequenceOfCbCtxT = ctx;","highlight_start":1,"highlight_end":45},{"text":"    let cur: &mut Sequence = &mut cb_ctx.cur;","highlight_start":1,"highlight_end":46},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    if !cur.buf.p.is_empty() {","highlight_start":1,"highlight_end":31},{"text":"        cur.next = Some(Sequence::new());","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        match &mut cur.next{","highlight_start":1,"highlight_end":29},{"text":"            None => return ERR_ALLOC_FAILED,","highlight_start":1,"highlight_end":45},{"text":"            Some(x) => cur = x,","highlight_start":1,"highlight_end":32},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    cur.buf.p = *start;","highlight_start":1,"highlight_end":24},{"text":"    cur.buf.len = len;","highlight_start":1,"highlight_end":23},{"text":"    cur.buf.tag = tag;","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    cb_ctx.cur = *cur;","highlight_start":1,"highlight_end":23},{"text":"    return 0;","highlight_start":1,"highlight_end":14},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\brief       Parses and splits an ASN.1 \"SEQUENCE OF <tag>\".","highlight_start":1,"highlight_end":65},{"text":"///              Updates the pointer to immediately behind the full sequence tag.","highlight_start":1,"highlight_end":82},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// This function allocates memory for the sequence elements. You can free","highlight_start":1,"highlight_end":75},{"text":"/// the allocated memory with mbedtls_asn1_sequence_free().","highlight_start":1,"highlight_end":60},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\note        On error, this function may return a partial list in \\p cur.","highlight_start":1,"highlight_end":78},{"text":"///              You must set `cur->next = NULL` before calling this function!","highlight_start":1,"highlight_end":79},{"text":"///              Otherwise it is impossible to distinguish a previously non-null","highlight_start":1,"highlight_end":81},{"text":"///              pointer from a pointer to an object allocated by this function.","highlight_start":1,"highlight_end":81},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\note        If the sequence is empty, this function does not modify","highlight_start":1,"highlight_end":73},{"text":"///              \\c *cur. If the sequence is valid and non-empty, this","highlight_start":1,"highlight_end":71},{"text":"///              function sets `cur->buf.tag` to \\p tag. This allows","highlight_start":1,"highlight_end":69},{"text":"///              callers to distinguish between an empty sequence and","highlight_start":1,"highlight_end":70},{"text":"///              a one-element sequence.","highlight_start":1,"highlight_end":41},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\param p     On entry, \\c *p points to the start of the ASN.1 element.","highlight_start":1,"highlight_end":75},{"text":"///              On successful completion, \\c *p is equal to \\p end.","highlight_start":1,"highlight_end":69},{"text":"///              On error, the value of \\c *p is undefined.","highlight_start":1,"highlight_end":60},{"text":"/// \\param end   End of data.","highlight_start":1,"highlight_end":30},{"text":"/// \\param cur   A ::mbedtls_asn1_sequence which this function fills.","highlight_start":1,"highlight_end":70},{"text":"///              When this function returns, \\c *cur is the head of a linked","highlight_start":1,"highlight_end":77},{"text":"///              list. Each node in this list is allocated with","highlight_start":1,"highlight_end":64},{"text":"///              mbedtls_calloc() apart from \\p cur itself, and should","highlight_start":1,"highlight_end":71},{"text":"///              therefore be freed with mbedtls_free().","highlight_start":1,"highlight_end":57},{"text":"///              The list describes the content of the sequence.","highlight_start":1,"highlight_end":65},{"text":"///              The head of the list (i.e. \\c *cur itself) describes the","highlight_start":1,"highlight_end":74},{"text":"///              first element, `*cur->next` describes the second element, etc.","highlight_start":1,"highlight_end":80},{"text":"///              For each element, `buf.tag == tag`, `buf.len` is the length","highlight_start":1,"highlight_end":77},{"text":"///              of the content of the content of the element, and `buf.p`","highlight_start":1,"highlight_end":75},{"text":"///              points to the first byte of the content (i.e. immediately","highlight_start":1,"highlight_end":75},{"text":"///              past the length of the element).","highlight_start":1,"highlight_end":50},{"text":"///              Note that list elements may be allocated even on error.","highlight_start":1,"highlight_end":73},{"text":"/// \\param tag   Each element of the sequence must have this tag.","highlight_start":1,"highlight_end":66},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\return      0 if successful.","highlight_start":1,"highlight_end":34},{"text":"/// \\return      #MBEDTLS_ERR_ASN1_LENGTH_MISMATCH if the input contains","highlight_start":1,"highlight_end":73},{"text":"///              extra data after a valid SEQUENCE OF \\p tag.","highlight_start":1,"highlight_end":62},{"text":"/// \\return      #MBEDTLS_ERR_ASN1_UNEXPECTED_TAG if the input starts with","highlight_start":1,"highlight_end":75},{"text":"///              an ASN.1 SEQUENCE in which an element has a tag that","highlight_start":1,"highlight_end":70},{"text":"///              is different from \\p tag.","highlight_start":1,"highlight_end":43},{"text":"/// \\return      #MBEDTLS_ERR_ASN1_ALLOC_FAILED if a memory allocation failed.","highlight_start":1,"highlight_end":79},{"text":"/// \\return      An ASN.1 error code if the input does not start with","highlight_start":1,"highlight_end":70},{"text":"///              a valid ASN.1 SEQUENCE.","highlight_start":1,"highlight_end":41},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"fn get_sequence_of(p: &mut SkipBuffer, end: usize, cur: &mut Sequence, tag: i32) -> i32 {","highlight_start":1,"highlight_end":90},{"text":"    let mut cb_ctx: SequenceOfCbCtxT ;","highlight_start":1,"highlight_end":39},{"text":"    cb_ctx.tag = tag;","highlight_start":1,"highlight_end":22},{"text":"    cb_ctx.cur = *cur;","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    for i in 0..mem::size_of::<Sequence>(){","highlight_start":1,"highlight_end":44},{"text":"        cur.buf.p[i] = 0;","highlight_start":1,"highlight_end":26},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    return traverse_sequence_of(p, end, 0xFF, tag as u8, 0, 0, Some(get_sequence_of_cb), &mut cb_ctx);","highlight_start":1,"highlight_end":103},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\brief          Free a heap-allocated linked list presentation of","highlight_start":1,"highlight_end":70},{"text":"///                 an ASN.1 sequence, including the first element.","highlight_start":1,"highlight_end":68},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// There are two common ways to manage the memory used for the representation","highlight_start":1,"highlight_end":79},{"text":"/// of a parsed ASN.1 sequence:","highlight_start":1,"highlight_end":32},{"text":"/// - Allocate a head node `mbedtls_asn1_sequence *head` with mbedtls_calloc().","highlight_start":1,"highlight_end":80},{"text":"///   Pass this node as the `cur` argument to mbedtls_asn1_get_sequence_of().","highlight_start":1,"highlight_end":78},{"text":"///   When you have finished processing the sequence,","highlight_start":1,"highlight_end":54},{"text":"///   call mbedtls_asn1_sequence_free() on `head`.","highlight_start":1,"highlight_end":51},{"text":"/// - Allocate a head node `mbedtls_asn1_sequence *head` in any manner,","highlight_start":1,"highlight_end":72},{"text":"///   for example on the stack. Make sure that `head->next == NULL`.","highlight_start":1,"highlight_end":69},{"text":"///   Pass `head` as the `cur` argument to mbedtls_asn1_get_sequence_of().","highlight_start":1,"highlight_end":75},{"text":"///   When you have finished processing the sequence,","highlight_start":1,"highlight_end":54},{"text":"///   call mbedtls_asn1_sequence_free() on `head->cur`,","highlight_start":1,"highlight_end":56},{"text":"///   then free `head` itself in the appropriate manner.","highlight_start":1,"highlight_end":57},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\param seq      The address of the first sequence component. This may","highlight_start":1,"highlight_end":74},{"text":"///                 be \\c NULL, in which case this functions returns","highlight_start":1,"highlight_end":69},{"text":"///                 immediately.","highlight_start":1,"highlight_end":33},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"fn sequence_free(seq: &mut Sequence) {","highlight_start":1,"highlight_end":39},{"text":"    loop{","highlight_start":1,"highlight_end":10},{"text":"        match &mut seq.next { ","highlight_start":1,"highlight_end":31},{"text":"            None => break,","highlight_start":1,"highlight_end":27},{"text":"            Some(x) => {","highlight_start":1,"highlight_end":25},{"text":"            let next: &mut Sequence = x;","highlight_start":1,"highlight_end":41},{"text":"            zeroize(&mut seq.buf.p );","highlight_start":1,"highlight_end":38},{"text":"            //mem::forget(seq);","highlight_start":1,"highlight_end":32},{"text":"            seq = next;","highlight_start":1,"highlight_end":24},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\brief                Traverse an ASN.1 SEQUENCE container and","highlight_start":1,"highlight_end":67},{"text":"///                       call a callback for each entry.","highlight_start":1,"highlight_end":58},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// This function checks that the input is a SEQUENCE of elements that","highlight_start":1,"highlight_end":71},{"text":"/// each have a \"must\" tag, and calls a callback function on the elements","highlight_start":1,"highlight_end":74},{"text":"/// that have a \"may\" tag.","highlight_start":1,"highlight_end":27},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// For example, to validate that the input is a SEQUENCE of `tag1` and call","highlight_start":1,"highlight_end":77},{"text":"/// `cb` on each element, use","highlight_start":1,"highlight_end":30},{"text":"/// ```","highlight_start":1,"highlight_end":8},{"text":"/// mbedtls_asn1_traverse_sequence_of(&p, end, 0xff, tag1, 0, 0, cb, ctx);","highlight_start":1,"highlight_end":75},{"text":"/// ```","highlight_start":1,"highlight_end":8},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// To validate that the input is a SEQUENCE of ANY and call `cb` on","highlight_start":1,"highlight_end":69},{"text":"/// each element, use","highlight_start":1,"highlight_end":22},{"text":"/// ```","highlight_start":1,"highlight_end":8},{"text":"/// mbedtls_asn1_traverse_sequence_of(&p, end, 0, 0, 0, 0, cb, ctx);","highlight_start":1,"highlight_end":69},{"text":"/// ```","highlight_start":1,"highlight_end":8},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// To validate that the input is a SEQUENCE of CHOICE {NULL, OCTET STRING}","highlight_start":1,"highlight_end":76},{"text":"/// and call `cb` on each element that is an OCTET STRING, use","highlight_start":1,"highlight_end":63},{"text":"/// ```","highlight_start":1,"highlight_end":8},{"text":"/// mbedtls_asn1_traverse_sequence_of(&p, end, 0xfe, 0x04, 0xff, 0x04, cb, ctx);","highlight_start":1,"highlight_end":81},{"text":"/// ```","highlight_start":1,"highlight_end":8},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// The callback is called on the elements with a \"may\" tag from left to","highlight_start":1,"highlight_end":73},{"text":"/// right. If the input is not a valid SEQUENCE of elements with a \"must\" tag,","highlight_start":1,"highlight_end":79},{"text":"/// the callback is called on the elements up to the leftmost point where","highlight_start":1,"highlight_end":74},{"text":"/// the input is invalid.","highlight_start":1,"highlight_end":26},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\warning              This function is still experimental and may change","highlight_start":1,"highlight_end":77},{"text":"///                       at any time.","highlight_start":1,"highlight_end":39},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\param p              The address of the pointer to the beginning of","highlight_start":1,"highlight_end":73},{"text":"///                       the ASN.1 SEQUENCE header. This is updated to","highlight_start":1,"highlight_end":72},{"text":"///                       point to the end of the ASN.1 SEQUENCE container","highlight_start":1,"highlight_end":75},{"text":"///                       on a successful invocation.","highlight_start":1,"highlight_end":54},{"text":"/// \\param end            The end of the ASN.1 SEQUENCE container.","highlight_start":1,"highlight_end":67},{"text":"/// \\param tag_must_mask  A mask to be applied to the ASN.1 tags found within","highlight_start":1,"highlight_end":78},{"text":"///                       the SEQUENCE before comparing to \\p tag_must_value.","highlight_start":1,"highlight_end":78},{"text":"/// \\param tag_must_val   The required value of each ASN.1 tag found in the","highlight_start":1,"highlight_end":76},{"text":"///                       SEQUENCE, after masking with \\p tag_must_mask.","highlight_start":1,"highlight_end":73},{"text":"///                       Mismatching tags lead to an error.","highlight_start":1,"highlight_end":61},{"text":"///                       For example, a value of \\c 0 for both \\p tag_must_mask","highlight_start":1,"highlight_end":81},{"text":"///                       and \\p tag_must_val means that every tag is allowed,","highlight_start":1,"highlight_end":79},{"text":"///                       while a value of \\c 0xFF for \\p tag_must_mask means","highlight_start":1,"highlight_end":78},{"text":"///                       that \\p tag_must_val is the only allowed tag.","highlight_start":1,"highlight_end":72},{"text":"/// \\param tag_may_mask   A mask to be applied to the ASN.1 tags found within","highlight_start":1,"highlight_end":78},{"text":"///                       the SEQUENCE before comparing to \\p tag_may_value.","highlight_start":1,"highlight_end":77},{"text":"/// \\param tag_may_val    The desired value of each ASN.1 tag found in the","highlight_start":1,"highlight_end":75},{"text":"///                       SEQUENCE, after masking with \\p tag_may_mask.","highlight_start":1,"highlight_end":72},{"text":"///                       Mismatching tags will be silently ignored.","highlight_start":1,"highlight_end":69},{"text":"///                       For example, a value of \\c 0 for \\p tag_may_mask and","highlight_start":1,"highlight_end":79},{"text":"///                       \\p tag_may_val means that any tag will be considered,","highlight_start":1,"highlight_end":80},{"text":"///                       while a value of \\c 0xFF for \\p tag_may_mask means","highlight_start":1,"highlight_end":77},{"text":"///                       that all tags with value different from \\p tag_may_val","highlight_start":1,"highlight_end":81},{"text":"///                       will be ignored.","highlight_start":1,"highlight_end":43},{"text":"/// \\param cb             The callback to trigger for each component","highlight_start":1,"highlight_end":69},{"text":"///                       in the ASN.1 SEQUENCE that matches \\p tag_may_val.","highlight_start":1,"highlight_end":77},{"text":"///                       The callback function is called with the following","highlight_start":1,"highlight_end":77},{"text":"///                       parameters:","highlight_start":1,"highlight_end":38},{"text":"///                       - \\p ctx.","highlight_start":1,"highlight_end":36},{"text":"///                       - The tag of the current element.","highlight_start":1,"highlight_end":60},{"text":"///                       - A pointer to the start of the current element's","highlight_start":1,"highlight_end":76},{"text":"///                         content inside the input.","highlight_start":1,"highlight_end":54},{"text":"///                       - The length of the content of the current element.","highlight_start":1,"highlight_end":78},{"text":"///                       If the callback returns a non-zero value,","highlight_start":1,"highlight_end":68},{"text":"///                       the function stops immediately,","highlight_start":1,"highlight_end":58},{"text":"///                       forwarding the callback's return value.","highlight_start":1,"highlight_end":66},{"text":"/// \\param ctx            The context to be passed to the callback \\p cb.","highlight_start":1,"highlight_end":74},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\return               \\c 0 if successful the entire ASN.1 SEQUENCE","highlight_start":1,"highlight_end":71},{"text":"///                       was traversed without parsing or callback errors.","highlight_start":1,"highlight_end":76},{"text":"/// \\return               #MBEDTLS_ERR_ASN1_LENGTH_MISMATCH if the input","highlight_start":1,"highlight_end":73},{"text":"///                       contains extra data after a valid SEQUENCE","highlight_start":1,"highlight_end":69},{"text":"///                       of elements with an accepted tag.","highlight_start":1,"highlight_end":60},{"text":"/// \\return               #MBEDTLS_ERR_ASN1_UNEXPECTED_TAG if the input starts","highlight_start":1,"highlight_end":79},{"text":"///                       with an ASN.1 SEQUENCE in which an element has a tag","highlight_start":1,"highlight_end":79},{"text":"///                       that is not accepted.","highlight_start":1,"highlight_end":48},{"text":"/// \\return               An ASN.1 error code if the input does not start with","highlight_start":1,"highlight_end":79},{"text":"///                       a valid ASN.1 SEQUENCE.","highlight_start":1,"highlight_end":50},{"text":"/// \\return               A non-zero error code forwarded from the callback","highlight_start":1,"highlight_end":76},{"text":"///                       \\p cb in case the latter returns a non-zero value.","highlight_start":1,"highlight_end":77},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"fn zeroize(a: &mut Vec<u8>){","highlight_start":1,"highlight_end":29},{"text":"    for i in &mut a.iter_mut(){","highlight_start":1,"highlight_end":32},{"text":"        *i = 0;","highlight_start":1,"highlight_end":16},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"fn traverse_sequence_of(","highlight_start":1,"highlight_end":25},{"text":"    p: &mut SkipBuffer, ","highlight_start":1,"highlight_end":25},{"text":"    end: usize, ","highlight_start":1,"highlight_end":17},{"text":"    tag_must_mask: u8,","highlight_start":1,"highlight_end":23},{"text":"    tag_must_val: u8,","highlight_start":1,"highlight_end":22},{"text":"    tag_may_mask: u8,","highlight_start":1,"highlight_end":22},{"text":"    tag_may_val: u8,","highlight_start":1,"highlight_end":21},{"text":"    cb: Option<fn (","highlight_start":1,"highlight_end":20},{"text":"        ctx: &mut SequenceOfCbCtxT,","highlight_start":1,"highlight_end":36},{"text":"        tag: i32,","highlight_start":1,"highlight_end":18},{"text":"        start: &mut Vec<u8>,","highlight_start":1,"highlight_end":29},{"text":"        len: usize ","highlight_start":1,"highlight_end":20},{"text":"        ) -> i32>,","highlight_start":1,"highlight_end":19},{"text":"    ctx: &mut SequenceOfCbCtxT","highlight_start":1,"highlight_end":31},{"text":"    ) -> i32{","highlight_start":1,"highlight_end":14},{"text":"        let mut ret: i32;","highlight_start":1,"highlight_end":26},{"text":"        let mut len: usize;","highlight_start":1,"highlight_end":28},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"        /* Get main sequence tag */","highlight_start":1,"highlight_end":36},{"text":"        ret = get_tag(p, end, &mut len, (CONSTRUCTED | SEQUENCE).into());","highlight_start":1,"highlight_end":74},{"text":"        if ret != 0{","highlight_start":1,"highlight_end":21},{"text":"            return ret;","highlight_start":1,"highlight_end":24},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"        if (p.ptr + len) != end{","highlight_start":1,"highlight_end":33},{"text":"            return ERR_LENGTH_MISMATCH;","highlight_start":1,"highlight_end":40},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"        while p.ptr < end{","highlight_start":1,"highlight_end":27},{"text":"            p.ptr = p.ptr + 1;","highlight_start":1,"highlight_end":31},{"text":"            let tag: u8 = p.buf[p.ptr];","highlight_start":1,"highlight_end":40},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"            if (tag & tag_must_mask) != tag_must_val{","highlight_start":1,"highlight_end":54},{"text":"                return ERR_UNEXPECTED_TAG;","highlight_start":1,"highlight_end":43},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            ","highlight_start":1,"highlight_end":13},{"text":"            ret = get_len(p, end, &mut len);","highlight_start":1,"highlight_end":45},{"text":"            if ret != 0{","highlight_start":1,"highlight_end":25},{"text":"                return ret;","highlight_start":1,"highlight_end":28},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"            if (tag & tag_may_mask) == tag_may_val{","highlight_start":1,"highlight_end":52},{"text":"                if let Some(f) = cb {","highlight_start":1,"highlight_end":38},{"text":"                    ret = f(ctx, tag.into() , &mut p.buf, len);","highlight_start":1,"highlight_end":64},{"text":"                    if ret != 0{","highlight_start":1,"highlight_end":33},{"text":"                        return ret;","highlight_start":1,"highlight_end":36},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                   ","highlight_start":1,"highlight_end":20},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            ","highlight_start":1,"highlight_end":13},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            p.ptr = p.ptr + len;","highlight_start":1,"highlight_end":33},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"        return 0;","highlight_start":1,"highlight_end":18},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"#[cfg(feature = \"BIGNUM\")]","highlight_start":1,"highlight_end":27},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\brief       Retrieve an integer ASN.1 tag and its value.","highlight_start":1,"highlight_end":62},{"text":"///              Updates the pointer to immediately behind the full tag.","highlight_start":1,"highlight_end":73},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\param p     On entry, \\c *p points to the start of the ASN.1 element.","highlight_start":1,"highlight_end":75},{"text":"///              On successful completion, \\c *p points to the first byte","highlight_start":1,"highlight_end":74},{"text":"///              beyond the ASN.1 element.","highlight_start":1,"highlight_end":43},{"text":"///              On error, the value of \\c *p is undefined.","highlight_start":1,"highlight_end":60},{"text":"/// \\param end   End of data.","highlight_start":1,"highlight_end":30},{"text":"/// \\param X     On success, the parsed value.","highlight_start":1,"highlight_end":47},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\return      0 if successful.","highlight_start":1,"highlight_end":34},{"text":"/// \\return      An ASN.1 error code if the input does not start with","highlight_start":1,"highlight_end":70},{"text":"///              a valid ASN.1 INTEGER.","highlight_start":1,"highlight_end":40},{"text":"/// \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the parsed value does","highlight_start":1,"highlight_end":75},{"text":"///              not fit in an \\c int.","highlight_start":1,"highlight_end":39},{"text":"/// \\return      An MPI error code if the parsed value is too large.","highlight_start":1,"highlight_end":69},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"fn get_mpi(p: &mut SkipBuffer, end: usize, x: &mut bignum::mpi) -> i32 {","highlight_start":1,"highlight_end":73},{"text":"    let mut ret: i32 = ERROR_CORRUPTION_DETECTED;","highlight_start":1,"highlight_end":50},{"text":"    let len: usize;","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    ret = get_tag(p, end, &len,INTEGER);","highlight_start":1,"highlight_end":41},{"text":"    if ret != 0{","highlight_start":1,"highlight_end":17},{"text":"        return ret;","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    ret = super::bignum::read_binary(x, p.ptr, len);","highlight_start":1,"highlight_end":53},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    p.ptr = p.ptr + len;","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    return ret;","highlight_start":1,"highlight_end":16},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\brief       Retrieve an AlgorithmIdentifier ASN.1 sequence.","highlight_start":1,"highlight_end":65},{"text":"///              Updates the pointer to immediately behind the full","highlight_start":1,"highlight_end":68},{"text":"///              AlgorithmIdentifier.","highlight_start":1,"highlight_end":38},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\param p     On entry, \\c *p points to the start of the ASN.1 element.","highlight_start":1,"highlight_end":75},{"text":"///              On successful completion, \\c *p points to the first byte","highlight_start":1,"highlight_end":74},{"text":"///              beyond the AlgorithmIdentifier element.","highlight_start":1,"highlight_end":57},{"text":"///              On error, the value of \\c *p is undefined.","highlight_start":1,"highlight_end":60},{"text":"/// \\param end   End of data.","highlight_start":1,"highlight_end":30},{"text":"/// \\param alg   The buffer to receive the OID.","highlight_start":1,"highlight_end":48},{"text":"/// \\param params The buffer to receive the parameters.","highlight_start":1,"highlight_end":56},{"text":"///              This is zeroized if there are no parameters.","highlight_start":1,"highlight_end":62},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\return      0 if successful or a specific ASN.1 or MPI error code.","highlight_start":1,"highlight_end":72},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"fn get_alg(p: &mut SkipBuffer, end: usize, alg: &mut Buf, params: &mut Buf) -> i32{","highlight_start":1,"highlight_end":84},{"text":"    let mut ret: i32 =ERROR_CORRUPTION_DETECTED;","highlight_start":1,"highlight_end":49},{"text":"    let mut len: usize;","highlight_start":1,"highlight_end":24},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    ret = get_tag(p, end, &mut len, (CONSTRUCTED | SEQUENCE).into());","highlight_start":1,"highlight_end":70},{"text":"    if ret != 0{","highlight_start":1,"highlight_end":17},{"text":"       return ret; ","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    if (end - p.ptr) < 1{","highlight_start":1,"highlight_end":26},{"text":"        return ERR_OUT_OF_DATA;","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    alg.tag = p.buf[p.ptr].into();","highlight_start":1,"highlight_end":35},{"text":"    end = p.ptr + len;","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    ret =get_tag(p, end, &mut alg.len, OID.into());","highlight_start":1,"highlight_end":52},{"text":"    if ret != 0{","highlight_start":1,"highlight_end":17},{"text":"        return ret;","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    alg.p = p.buf;","highlight_start":1,"highlight_end":19},{"text":"    p.ptr = p.ptr + alg.len;","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    if p.ptr == end{","highlight_start":1,"highlight_end":21},{"text":"        zeroize(&mut params.p);","highlight_start":1,"highlight_end":32},{"text":"        return 0;","highlight_start":1,"highlight_end":18},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    params.tag = p.buf[p.ptr].into();","highlight_start":1,"highlight_end":38},{"text":"    p.ptr = p.ptr + 1;","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    ret = get_len(p, end, &mut params.len);","highlight_start":1,"highlight_end":44},{"text":"    if ret != 0{","highlight_start":1,"highlight_end":17},{"text":"        return ret;","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    params.p = p.buf;","highlight_start":1,"highlight_end":22},{"text":"    p.ptr = p.ptr + params.len;","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    if p.ptr != end{","highlight_start":1,"highlight_end":21},{"text":"        return ERR_LENGTH_MISMATCH;","highlight_start":1,"highlight_end":36},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    return 0;","highlight_start":1,"highlight_end":14},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\brief       Retrieve an AlgorithmIdentifier ASN.1 sequence with NULL or no","highlight_start":1,"highlight_end":80},{"text":"///              params.","highlight_start":1,"highlight_end":25},{"text":"///              Updates the pointer to immediately behind the full","highlight_start":1,"highlight_end":68},{"text":"///              AlgorithmIdentifier.","highlight_start":1,"highlight_end":38},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\param p     On entry, \\c *p points to the start of the ASN.1 element.","highlight_start":1,"highlight_end":75},{"text":"///              On successful completion, \\c *p points to the first byte","highlight_start":1,"highlight_end":74},{"text":"///              beyond the AlgorithmIdentifier element.","highlight_start":1,"highlight_end":57},{"text":"///              On error, the value of \\c *p is undefined.","highlight_start":1,"highlight_end":60},{"text":"/// \\param end   End of data.","highlight_start":1,"highlight_end":30},{"text":"/// \\param alg   The buffer to receive the OID.","highlight_start":1,"highlight_end":48},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\return      0 if successful or a specific ASN.1 or MPI error code.","highlight_start":1,"highlight_end":72},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"fn get_alg_null(p: &mut SkipBuffer, end: usize, alg: &mut Buf) -> i32 {","highlight_start":1,"highlight_end":72},{"text":"    let mut ret: i32 = ERROR_CORRUPTION_DETECTED;","highlight_start":1,"highlight_end":50},{"text":"    let mut params: Buf;","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    for i in 0..mem::size_of::<Buf>(){","highlight_start":1,"highlight_end":39},{"text":"        params.p[i] = 0;","highlight_start":1,"highlight_end":25},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    ret = get_alg( p, end, alg, &mut params);","highlight_start":1,"highlight_end":46},{"text":"    if ret != 0{","highlight_start":1,"highlight_end":17},{"text":"        return ret;","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    if (params.tag != NULL.into() && params.tag != 0) || params.len != 0{","highlight_start":1,"highlight_end":74},{"text":"        return ERR_INVALID_DATA;","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    return 0;","highlight_start":1,"highlight_end":14},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\brief       Find a specific named_data entry in a sequence or list based on","highlight_start":1,"highlight_end":81},{"text":"///              the OID.","highlight_start":1,"highlight_end":26},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\param list  The list to seek through","highlight_start":1,"highlight_end":42},{"text":"/// \\param oid   The OID to look for","highlight_start":1,"highlight_end":37},{"text":"/// \\param len   Size of the OID","highlight_start":1,"highlight_end":33},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\return      NULL if not found, or a pointer to the existing entry.","highlight_start":1,"highlight_end":72},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"fn cmp_ (list: &Vec<u8>, oid: &Vec<u8>, len: usize) -> i32{","highlight_start":1,"highlight_end":60},{"text":"    for i in 0..len{","highlight_start":1,"highlight_end":21},{"text":"        if list[i] != oid[i] { ","highlight_start":1,"highlight_end":32},{"text":"            return 1; ","highlight_start":1,"highlight_end":23},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    return 0;","highlight_start":1,"highlight_end":14},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"fn find_named_data<'a>(list: &'a mut NamedData, oid: &Vec<u8>, len: usize) -> &'a mut NamedData{","highlight_start":1,"highlight_end":97},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    loop{  ","highlight_start":1,"highlight_end":12},{"text":"    match &mut list.next {","highlight_start":1,"highlight_end":27},{"text":"        Some(x) => {","highlight_start":1,"highlight_end":21},{"text":"            if (list.oid.len == len) &&  cmp_(&list.oid.p, oid, len) == 0{","highlight_start":1,"highlight_end":75},{"text":"                break","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            list = x;},","highlight_start":1,"highlight_end":24},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    return list; ","highlight_start":1,"highlight_end":18},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\brief       Free a mbedtls_asn1_named_data entry","highlight_start":1,"highlight_end":54},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\param entry The named data entry to free.","highlight_start":1,"highlight_end":47},{"text":"///              This function calls mbedtls_free() on","highlight_start":1,"highlight_end":55},{"text":"///              `entry->oid.p` and `entry->val.p`.","highlight_start":1,"highlight_end":52},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"fn free_named_data(entry: NamedData) {   ","highlight_start":1,"highlight_end":42},{"text":"    // In rust we just need to ","highlight_start":1,"highlight_end":32},{"text":"    // zero out this memory. ","highlight_start":1,"highlight_end":30},{"text":"    // Because once you leave","highlight_start":1,"highlight_end":30},{"text":"    // this function object will ","highlight_start":1,"highlight_end":34},{"text":"    // be automatically freed.","highlight_start":1,"highlight_end":31},{"text":"    match &mut entry.next{","highlight_start":1,"highlight_end":27},{"text":"        None => return,","highlight_start":1,"highlight_end":24},{"text":"        Some(x) => { ","highlight_start":1,"highlight_end":22},{"text":"            //mem::forget(entry.oid.p);","highlight_start":1,"highlight_end":40},{"text":"            //mem::forget(entry.val.p);","highlight_start":1,"highlight_end":40},{"text":"            zeroize(&mut entry.val.p);","highlight_start":1,"highlight_end":39},{"text":"            zeroize(&mut entry.oid.p);","highlight_start":1,"highlight_end":39},{"text":"        },","highlight_start":1,"highlight_end":11},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\brief       Free all entries in a mbedtls_asn1_named_data list.","highlight_start":1,"highlight_end":69},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"/// \\param head  Pointer to the head of the list of named data entries to free.","highlight_start":1,"highlight_end":80},{"text":"///              This function calls mbedtls_asn1_free_named_data() and","highlight_start":1,"highlight_end":72},{"text":"///              mbedtls_free() on each list element and","highlight_start":1,"highlight_end":57},{"text":"///              sets \\c *head to \\c NULL.","highlight_start":1,"highlight_end":43},{"text":"/// ","highlight_start":1,"highlight_end":5},{"text":"fn free_named_data_list(head: &mut NamedData){","highlight_start":1,"highlight_end":47},{"text":"    let mut cur: &mut NamedData;","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    loop{","highlight_start":1,"highlight_end":10},{"text":"        cur = head;","highlight_start":1,"highlight_end":20},{"text":"        match &mut head.next {","highlight_start":1,"highlight_end":31},{"text":"            Some(x) => { ","highlight_start":1,"highlight_end":26},{"text":"                head = x ;","highlight_start":1,"highlight_end":27},{"text":"                free_named_data(*cur);","highlight_start":1,"highlight_end":39},{"text":"                //mem::forget(cur);","highlight_start":1,"highlight_end":36},{"text":"            ","highlight_start":1,"highlight_end":13},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"consider adding a `main` function to `src/main.rs`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0601]\u001b[0m\u001b[0m\u001b[1m: `main` function not found in crate `asn1_parse`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:1:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[cfg(feature = \"BIGNUM\")]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse super::bignum;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::mem;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m///\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m951\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m952\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconsider adding a `main` function to `src/main.rs`\u001b[0m\n\n"}
{"message":"aborting due to previous error","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to previous error\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0601`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0601`.\u001b[0m\n"}
