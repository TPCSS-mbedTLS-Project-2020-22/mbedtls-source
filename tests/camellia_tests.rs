use mbed::cipher::camellia::*;
#[test]
fn initialize_camellia_cipher_128() {
    let keybits: u32 = 128;
    let key = [4u8; 32];
    let cipher = CamelliaContext::init(key, keybits);
    assert_eq!(3, cipher.nr);
}
#[test]
fn initialize_camellia_cipher_256() {
    let keybits: u32 = 256;
    let key = [4u8; 32];
    let cipher = CamelliaContext::init(key, keybits);
    assert_eq!(4, cipher.nr);
}

#[test]
fn camellia_fiestel() {
    let x: [u8; 8] = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0];
    let y: [u8; 8] = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0];
    let f_out = CamelliaContext::f(u64::from_ne_bytes(x), u64::from_ne_bytes(y));
    assert_eq!("a838e0a8", format!("{:x}", f_out));
}

#[test]
fn camellia_fiestel_fl() {
    let x: [u8; 8] = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0];
    let y: [u8; 8] = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0];
    let f_out = CamelliaContext::f(u64::from_ne_bytes(x), u64::from_ne_bytes(y));
    assert_eq!("a838e0a8", format!("{:x}", f_out));
}

#[test]
fn camellia_fiestel_fl_inv() {
    let x: [u8; 8] = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0];
    let y: [u8; 8] = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0];
    let f_out = CamelliaContext::f(u64::from_ne_bytes(x), u64::from_ne_bytes(y));
    assert_eq!("a838e0a8", format!("{:x}", f_out));
}

#[test]
fn round_keys_encrypt() {
    let keybits: u32 = 128;
    // let key = [4u8; 16];
    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    let expected_key: [u32; 68] = [
        0x1234567, 0x89abcdef, 0xfedcba98, 0x76543210, 0xae71c3d5, 0x5ba6bf1d, 0x169240a7,
        0x95f89256, 0xa2b3c4d5, 0xe6f7ff6e, 0x5d4c3b2a, 0x19080091, 0xe1eaadd3, 0x5f8e8b49,
        0x2053cafc, 0x492b5738, 0x56e9afc7, 0x45a49029, 0xe57e2495, 0xab9c70f5, 0x79bdffdb,
        0x97530eca, 0x86420024, 0x68acf135, 0xd7e3a2d2, 0x4814f2bf, 0x123456, 0x789abcde,
        0xd169240a, 0x795f8925, 0x6ae71c3d, 0x55ba6bf1, 0x97530eca, 0x86420024, 0x68acf135,
        0x79bdffdb, 0x1d950c84, 0x48d159, 0xe26af37b, 0xffb72ea6, 0xe57e2495, 0xab9c70f5,
        0x56e9afc7, 0x45a49029, 0x19080091, 0xa2b3c4d5, 0xe6f7ff6e, 0x5d4c3b2a, 0x492b5738,
        0xe1eaadd3, 0x5f8e8b49, 0x2053cafc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0,
    ];
    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(ENCRYPT);

    assert_eq!(cipher.rk, expected_key);
}

#[test]
fn round_keys_decrypt() {
    let keybits: u32 = 128;
    // let key = [4u8; 16];
    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    let expected_key: [u32; 68] = [
        0x492b5738, 0xe1eaadd3, 0x5f8e8b49, 0x2053cafc, 0xe6f7ff6e, 0x5d4c3b2a, 0x19080091,
        0xa2b3c4d5, 0x56e9afc7, 0x45a49029, 0xe57e2495, 0xab9c70f5, 0xe26af37b, 0xffb72ea6,
        0x1d950c84, 0x48d159, 0x68acf135, 0x79bdffdb, 0x97530eca, 0x86420024, 0x6ae71c3d,
        0x55ba6bf1, 0xd169240a, 0x795f8925, 0x123456, 0x789abcde, 0xd7e3a2d2, 0x4814f2bf,
        0x86420024, 0x68acf135, 0x79bdffdb, 0x97530eca, 0xe57e2495, 0xab9c70f5, 0x56e9afc7,
        0x45a49029, 0x2053cafc, 0x492b5738, 0xe1eaadd3, 0x5f8e8b49, 0x5d4c3b2a, 0x19080091,
        0xa2b3c4d5, 0xe6f7ff6e, 0x169240a7, 0x95f89256, 0xae71c3d5, 0x5ba6bf1d, 0x1234567,
        0x89abcdef, 0xfedcba98, 0x76543210, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0,
    ];
    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(DECRYPT);

    assert_eq!(cipher.rk, expected_key);
}

#[test]
fn encrypt_ecb_128() {
    let keybits: u32 = 128;
    // let key = [4u8; 16];
    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(ENCRYPT);

    let plain_text: [u8; 16] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10,
    ];

    let actual_ciphertext = cipher.mbedtls_camellia_crypt_ecb(plain_text);

    let expected_ciphertext: [u8; 16] = [
        0x67, 0x67, 0x31, 0x38, 0x54, 0x96, 0x69, 0x73, 0x8, 0x57, 0x6, 0x56, 0x48, 0xea, 0xbe,
        0x43,
    ];

    assert_eq!(actual_ciphertext, expected_ciphertext);
}

#[test]
fn decrypt_ecb_128() {
    let keybits: u32 = 128;
    // let key = [4u8; 16];
    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    let mut cipher = CamelliaContext::init(key, keybits);

    cipher.set_mode(DECRYPT);

    let cipher_text: [u8; 16] = [
        0x67, 0x67, 0x31, 0x38, 0x54, 0x96, 0x69, 0x73, 0x8, 0x57, 0x6, 0x56, 0x48, 0xea, 0xbe,
        0x43,
    ];

    let actual_plaintext = cipher.mbedtls_camellia_crypt_ecb(cipher_text);

    let expected_plaintext: [u8; 16] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10,
    ];

    assert_eq!(actual_plaintext, expected_plaintext);
}
#[test]
fn round_keys_encrypt_192() {
    let keybits: u32 = 192;
    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(ENCRYPT);

    let exp: [u32; 68] = [
        0x1234567, 0x89abcdef, 0xfedcba98, 0x76543210, 0x8f3afac1, 0xcc974396, 0xc098a0b7,
        0xe38b4df2, 0x9119a22a, 0xb33bfff7, 0x6ee65dd5, 0x4cc40008, 0x5109ae22, 0x714467b1,
        0xb5035d, 0x5f6983b3, 0xd115599d, 0xfffbb773, 0x2eeaa662, 0x4488c, 0x7325d0e5, 0xb026282d,
        0xf8e2d37c, 0xa3cebeb0, 0x79bdffdb, 0x97530eca, 0x86420024, 0x68acf135, 0x9c5119ec,
        0x402d40d7, 0x57da60ec, 0xd4426b88, 0xffedcba9, 0x87654321, 0x123456, 0x789abcde,
        0x7ffeeddc, 0xcbbaa998, 0x80011223, 0x34455667, 0x6c098a0b, 0x7e38b4df, 0x28f3afac,
        0x1cc97439, 0x97530eca, 0x86420024, 0x68acf135, 0x79bdffdb, 0x402d40d7, 0x57da60ec,
        0xd4426b88, 0x9c5119ec, 0x2eeaa662, 0x4488c, 0xd115599d, 0xfffbb773, 0x81aeafb4,
        0xc1d9a884, 0xd71138a2, 0x33d8805a, 0x19080091, 0xa2b3c4d5, 0xe6f7ff6e, 0x5d4c3b2a,
        0xa6f9479d, 0x7d60e64b, 0xa1cb604c, 0x505bf1c5,
    ];

    assert_eq!(cipher.rk, exp);
}

#[test]
fn round_keys_decrypt_192() {
    let keybits: u32 = 192;
    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(DECRYPT);
    let exp: [u32; 68] = [
        0xa6f9479d, 0x7d60e64b, 0xa1cb604c, 0x505bf1c5, 0xe6f7ff6e, 0x5d4c3b2a, 0x19080091,
        0xa2b3c4d5, 0xd71138a2, 0x33d8805a, 0x81aeafb4, 0xc1d9a884, 0xd115599d, 0xfffbb773,
        0x2eeaa662, 0x4488c, 0xd4426b88, 0x9c5119ec, 0x402d40d7, 0x57da60ec, 0x68acf135,
        0x79bdffdb, 0x97530eca, 0x86420024, 0x28f3afac, 0x1cc97439, 0x6c098a0b, 0x7e38b4df,
        0x80011223, 0x34455667, 0x7ffeeddc, 0xcbbaa998, 0x123456, 0x789abcde, 0xffedcba9,
        0x87654321, 0x57da60ec, 0xd4426b88, 0x9c5119ec, 0x402d40d7, 0x86420024, 0x68acf135,
        0x79bdffdb, 0x97530eca, 0xf8e2d37c, 0xa3cebeb0, 0x7325d0e5, 0xb026282d, 0x2eeaa662,
        0x4488c, 0xd115599d, 0xfffbb773, 0xb5035d, 0x5f6983b3, 0x5109ae22, 0x714467b1, 0x6ee65dd5,
        0x4cc40008, 0x9119a22a, 0xb33bfff7, 0xc098a0b7, 0xe38b4df2, 0x8f3afac1, 0xcc974396,
        0x1234567, 0x89abcdef, 0xfedcba98, 0x76543210,
    ];

    assert_eq!(cipher.rk, exp);
}
#[test]
fn encrypt_ecb_192() {
    let keybits: u32 = 192;
    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(ENCRYPT);

    let plain_text: [u8; 16] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10,
    ];

    let actual_ciphertext = cipher.mbedtls_camellia_crypt_ecb(plain_text);

    let expected_ciphertext: [u8; 16] = [
        0xb4, 0x99, 0x34, 0x01, 0xb3, 0xe9, 0x96, 0xf8, 0x4e, 0xe5, 0xce, 0xe7, 0xd7, 0x9b, 0x09,
        0xb9,
    ];

    assert_eq!(actual_ciphertext, expected_ciphertext);
}
#[test]
fn decrypt_ecb_192() {
    let keybits: u32 = 192;
    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(DECRYPT);

    let ciphertext: [u8; 16] = [
        0xb4, 0x99, 0x34, 0x01, 0xb3, 0xe9, 0x96, 0xf8, 0x4e, 0xe5, 0xce, 0xe7, 0xd7, 0x9b, 0x09,
        0xb9,
    ];

    let expected_plain_text: [u8; 16] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10,
    ];

    let actual_plaintext = cipher.mbedtls_camellia_crypt_ecb(ciphertext);

    assert_eq!(actual_plaintext, expected_plain_text);
}
#[test]
fn encrypt_ecb_256() {
    let keybits: u32 = 256;

    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd,
        0xee, 0xff,
    ];

    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(ENCRYPT);

    let plain_text: [u8; 16] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10,
    ];

    let actual_ciphertext = cipher.mbedtls_camellia_crypt_ecb(plain_text);

    let expected_ciphertext: [u8; 16] = [
        0x9a, 0xcc, 0x23, 0x7d, 0xff, 0x16, 0xd7, 0x6c, 0x20, 0xef, 0x7c, 0x91, 0x9e, 0x3a, 0x75,
        0x09,
    ];

    assert_eq!(actual_ciphertext, expected_ciphertext);
}
#[test]
fn decrypt_ecb_256() {
    let keybits: u32 = 256;

    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd,
        0xee, 0xff,
    ];

    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(DECRYPT);

    let ciphertext: [u8; 16] = [
        0x9a, 0xcc, 0x23, 0x7d, 0xff, 0x16, 0xd7, 0x6c, 0x20, 0xef, 0x7c, 0x91, 0x9e, 0x3a, 0x75,
        0x09,
    ];

    let expected_plain_text: [u8; 16] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10,
    ];

    let actual_plaintext = cipher.mbedtls_camellia_crypt_ecb(ciphertext);

    assert_eq!(actual_plaintext, expected_plain_text);
}

#[test]
fn round_keys_encrypt_256() {
    let keybits: u32 = 256;

    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd,
        0xee, 0xff,
    ];

    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(ENCRYPT);
    let exp: [u32; 68] = [
        0x1234567, 0x89abcdef, 0xfedcba98, 0x76543210, 0x38152142, 0x80a4d3c0, 0x1848fd9a,
        0xc7b1fe60, 0x9119a22a, 0xb33bc44c, 0xd55de66e, 0xf77f8008, 0xdad8236f, 0x83fd64dd,
        0xc8a5bf8c, 0x9bf70be8, 0xd115599d, 0xe2266aae, 0xf3377bbf, 0xc004488c, 0xa02934f0,
        0x6123f66, 0xb1ec7f98, 0xe054850, 0x79bdffdb, 0x97530eca, 0x86420024, 0x68acf135,
        0xe0ff5937, 0x72296fe3, 0x26fdc2fa, 0x36b608db, 0xffedcba9, 0x87654321, 0x123456,
        0x789abcde, 0x78899aab, 0xbccddeef, 0xf0011223, 0x34455667, 0x1848fd9, 0xac7b1fe6,
        0x3815214, 0x280a4d3c, 0x97530eca, 0x86420024, 0x68acf135, 0x79bdffdb, 0x72296fe3,
        0x26fdc2fa, 0x36b608db, 0xe0ff5937, 0xf3377bbf, 0xc004488c, 0xd115599d, 0xe2266aae,
        0xdfc64dfb, 0x85f46d6c, 0x11b7c1fe, 0xb26ee452, 0x19080091, 0xa2b3c4d5, 0xe6f7ff6e,
        0x5d4c3b2a, 0xff301c0a, 0x90a14052, 0x69e00c24, 0x7ecd63d8,
    ];

    assert_eq!(cipher.rk, exp);
}

#[test]
fn round_keys_decrypt_256() {
    let keybits: u32 = 256;

    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd,
        0xee, 0xff,
    ];

    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(DECRYPT);
    let exp: [u32; 68] = [
        0xff301c0a, 0x90a14052, 0x69e00c24, 0x7ecd63d8, 0xe6f7ff6e, 0x5d4c3b2a, 0x19080091,
        0xa2b3c4d5, 0x11b7c1fe, 0xb26ee452, 0xdfc64dfb, 0x85f46d6c, 0xd115599d, 0xe2266aae,
        0xf3377bbf, 0xc004488c, 0x36b608db, 0xe0ff5937, 0x72296fe3, 0x26fdc2fa, 0x68acf135,
        0x79bdffdb, 0x97530eca, 0x86420024, 0x3815214, 0x280a4d3c, 0x1848fd9, 0xac7b1fe6,
        0xf0011223, 0x34455667, 0x78899aab, 0xbccddeef, 0x123456, 0x789abcde, 0xffedcba9,
        0x87654321, 0x26fdc2fa, 0x36b608db, 0xe0ff5937, 0x72296fe3, 0x86420024, 0x68acf135,
        0x79bdffdb, 0x97530eca, 0xb1ec7f98, 0xe054850, 0xa02934f0, 0x6123f66, 0xf3377bbf,
        0xc004488c, 0xd115599d, 0xe2266aae, 0xc8a5bf8c, 0x9bf70be8, 0xdad8236f, 0x83fd64dd,
        0xd55de66e, 0xf77f8008, 0x9119a22a, 0xb33bc44c, 0x1848fd9a, 0xc7b1fe60, 0x38152142,
        0x80a4d3c0, 0x1234567, 0x89abcdef, 0xfedcba98, 0x76543210,
    ];

    assert_eq!(cipher.rk, exp);
}

#[test]
fn decrypt_cbc_128() {
    let keybits: u32 = 128;

    let key: [u8; 32] = [
        0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F,
        0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];

    let iv: [u8; 16] = [
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
        0x0F,
    ];

    let ciphertext: Vec<u8> = vec![
        0x16, 0x07, 0xCF, 0x49, 0x4B, 0x36, 0xBB, 0xF0, 0x0D, 0xAE, 0xB0, 0xB5, 0x03, 0xC8, 0x31,
        0xAB,
    ];

    let expectedtext: Vec<u8> = vec![
        0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17,
        0x2A,
    ];

    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(DECRYPT);

    let actual_plaintext = cipher.mbedtls_camellia_crypt_cbc(iv, 16, ciphertext);

    assert_eq!(actual_plaintext, expectedtext);
}

#[test]
fn encrypt_cbc_128() {
    let keybits: u32 = 128;

    let key: [u8; 32] = [
        0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F,
        0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];

    let iv: [u8; 16] = [
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
        0x0F,
    ];

    let text: Vec<u8> = vec![
        0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17,
        0x2A,
    ];

    let expected_ciphertext: Vec<u8> = vec![
        0x16, 0x07, 0xCF, 0x49, 0x4B, 0x36, 0xBB, 0xF0, 0x0D, 0xAE, 0xB0, 0xB5, 0x03, 0xC8, 0x31,
        0xAB,
    ];

    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(ENCRYPT);

    let actual_plaintext = cipher.mbedtls_camellia_crypt_cbc(iv, 16, text);

    assert_eq!(actual_plaintext, expected_ciphertext);
}

#[test]
fn decrypt_cbc_192() {
    let keybits: u32 = 192;

    let key: [u8; 32] = [
        0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52, 0xC8, 0x10, 0xF3, 0x2B, 0x80, 0x90, 0x79,
        0xE5, 0x62, 0xF8, 0xEA, 0xD2, 0x52, 0x2C, 0x6B, 0x7B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];

    let iv: [u8; 16] = [
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
        0x0F,
    ];

    let ciphertext: Vec<u8> = vec![
        0x2A, 0x48, 0x30, 0xAB, 0x5A, 0xC4, 0xA1, 0xA2, 0x40, 0x59, 0x55, 0xFD, 0x21, 0x95, 0xCF,
        0x93,
    ];

    let expectedtext: Vec<u8> = vec![
        0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17,
        0x2A,
    ];

    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(DECRYPT);

    let actual_plaintext = cipher.mbedtls_camellia_crypt_cbc(iv, 16, ciphertext);

    assert_eq!(actual_plaintext, expectedtext);
}

#[test]
fn encrypt_cbc_192() {
    let keybits: u32 = 192;

    let key: [u8; 32] = [
        0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52, 0xC8, 0x10, 0xF3, 0x2B, 0x80, 0x90, 0x79,
        0xE5, 0x62, 0xF8, 0xEA, 0xD2, 0x52, 0x2C, 0x6B, 0x7B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];

    let iv: [u8; 16] = [
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
        0x0F,
    ];

    let exp_ciphertext: Vec<u8> = vec![
        0x2A, 0x48, 0x30, 0xAB, 0x5A, 0xC4, 0xA1, 0xA2, 0x40, 0x59, 0x55, 0xFD, 0x21, 0x95, 0xCF,
        0x93,
    ];

    let plaintext: Vec<u8> = vec![
        0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17,
        0x2A,
    ];

    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(ENCRYPT);

    let actual_ciphertext = cipher.mbedtls_camellia_crypt_cbc(iv, 16, plaintext);

    assert_eq!(actual_ciphertext, exp_ciphertext);
}

#[test]
fn encrypt_cbc_256_round_keys() {
    let key: [u8; 32] = [
        0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE, 0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77,
        0x81, 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7, 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14,
        0xDF, 0xF4,
    ];
    let exp: [u32; 68] = [
        0x603deb10, 0x15ca71be, 0x2b73aef0, 0x857d7781, 0x6a197d8a, 0x29bf82c9, 0xe4fd70dc,
        0x9f20d2ab, 0x96039db0, 0x846b96cc, 0x851848a, 0x6ffa0f9a, 0xce267b33, 0x62c32f67,
        0x17adb548, 0x23f956bd, 0xced84235, 0xcb660428, 0xc24537fd, 0x7cd4b01, 0x8a6fe0b2,
        0x793f5c37, 0x27c834aa, 0xda865f62, 0x4e37c56e, 0x75de10af, 0xaef02c07, 0xbd6202b9,
        0xd8b0cbd9, 0xc5eb6d52, 0x8fe55af, 0x73899ecc, 0xe2b73aef, 0x857d778, 0x1603deb1,
        0x15ca71b, 0x72d9810a, 0x30914dff, 0x41f352c0, 0x73b6108d, 0x9e4fd70d, 0xc9f20d2a,
        0xb6a197d8, 0xa29bf82c, 0x75de10af, 0xaef02c07, 0xbd6202b9, 0x4e37c56e, 0xc5eb6d52,
        0x8fe55af, 0x73899ecc, 0xd8b0cbd9, 0xc24537fd, 0x7cd4b01, 0xced84235, 0xcb660428,
        0xdaa411fc, 0xab5ee713, 0x3d99b161, 0x97b38bd6, 0xbbc0b01e, 0xf5880ae5, 0x38df15b9,
        0xd77842be, 0x6955b50c, 0xbec514df, 0xc164f27e, 0xb86e4f90,
    ];

    let mut cipher = CamelliaContext::init(key, 256);
    cipher.set_mode(ENCRYPT);

    assert_eq!(cipher.rk, exp);
}

#[test]
fn decrypt_cbc_256_round_keys() {
    let key: [u8; 32] = [
        0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE, 0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77,
        0x81, 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7, 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14,
        0xDF, 0xF4,
    ];
    let exp: [u32; 68] = [
        0x6955b50c, 0xbec514df, 0xc164f27e, 0xb86e4f90, 0x38df15b9, 0xd77842be, 0xbbc0b01e,
        0xf5880ae5, 0x3d99b161, 0x97b38bd6, 0xdaa411fc, 0xab5ee713, 0xced84235, 0xcb660428,
        0xc24537fd, 0x7cd4b01, 0x73899ecc, 0xd8b0cbd9, 0xc5eb6d52, 0x8fe55af, 0xbd6202b9,
        0x4e37c56e, 0x75de10af, 0xaef02c07, 0xb6a197d8, 0xa29bf82c, 0x9e4fd70d, 0xc9f20d2a,
        0x41f352c0, 0x73b6108d, 0x72d9810a, 0x30914dff, 0x1603deb1, 0x15ca71b, 0xe2b73aef,
        0x857d778, 0x8fe55af, 0x73899ecc, 0xd8b0cbd9, 0xc5eb6d52, 0xaef02c07, 0xbd6202b9,
        0x4e37c56e, 0x75de10af, 0x27c834aa, 0xda865f62, 0x8a6fe0b2, 0x793f5c37, 0xc24537fd,
        0x7cd4b01, 0xced84235, 0xcb660428, 0x17adb548, 0x23f956bd, 0xce267b33, 0x62c32f67,
        0x851848a, 0x6ffa0f9a, 0x96039db0, 0x846b96cc, 0xe4fd70dc, 0x9f20d2ab, 0x6a197d8a,
        0x29bf82c9, 0x603deb10, 0x15ca71be, 0x2b73aef0, 0x857d7781,
    ];

    let mut cipher = CamelliaContext::init(key, 256);
    cipher.set_mode(DECRYPT);

    assert_eq!(cipher.rk, exp);
}

#[test]
fn decrypt_cbc_256() {
    let keybits: u32 = 256;

    let key: [u8; 32] = [
        0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE, 0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77,
        0x81, 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7, 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14,
        0xDF, 0xF4,
    ];

    let iv: [u8; 16] = [
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
        0x0F,
    ];

    let ciphertext: Vec<u8> = vec![
        0xE6, 0xCF, 0xA3, 0x5F, 0xC0, 0x2B, 0x13, 0x4A, 0x4D, 0x2C, 0x0B, 0x67, 0x37, 0xAC, 0x3E,
        0xDA,
    ];

    let expectedtext: Vec<u8> = vec![
        0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17,
        0x2A,
    ];

    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(DECRYPT);

    let actual_plaintext = cipher.mbedtls_camellia_crypt_cbc(iv, 16, ciphertext);

    assert_eq!(actual_plaintext, expectedtext);
}

#[test]
fn encrypt_cbc_256() {
    let keybits: u32 = 256;

    let key: [u8; 32] = [
        0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE, 0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77,
        0x81, 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7, 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14,
        0xDF, 0xF4,
    ];

    let iv: [u8; 16] = [
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
        0x0F,
    ];

    let plaintext: Vec<u8> = vec![
        0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17,
        0x2A,
    ];

    let expectedciphertext: Vec<u8> = vec![
        0xE6, 0xCF, 0xA3, 0x5F, 0xC0, 0x2B, 0x13, 0x4A, 0x4D, 0x2C, 0x0B, 0x67, 0x37, 0xAC, 0x3E,
        0xDA,
    ];

    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(ENCRYPT);

    let actual_cipher = cipher.mbedtls_camellia_crypt_cbc(iv, 16, plaintext);

    assert_eq!(actual_cipher, expectedciphertext);
}
