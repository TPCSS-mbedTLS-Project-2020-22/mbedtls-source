use mbed::cipher::camellia::*;
#[test]
fn initialize_camellia_cipher_128() {
    let keybits: u32 = 128;
    let key = [4u8; 32];
    let cipher = CamelliaContext::init(key, keybits);
    assert_eq!(3, cipher.nr);
}
#[test]
fn initialize_camellia_cipher_256() {
    let keybits: u32 = 256;
    let key = [4u8; 32];
    let cipher = CamelliaContext::init(key, keybits);
    assert_eq!(4, cipher.nr);
}

#[test]
fn camellia_fiestel() {
    let x: [u8; 8] = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0];
    let y: [u8; 8] = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0];
    let f_out = CamelliaContext::f(u64::from_ne_bytes(x), u64::from_ne_bytes(y));
    assert_eq!("a838e0a8", format!("{:x}", f_out));
}

#[test]
fn camellia_fiestel_fl() {
    let x: [u8; 8] = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0];
    let y: [u8; 8] = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0];
    let f_out = CamelliaContext::f(u64::from_ne_bytes(x), u64::from_ne_bytes(y));
    assert_eq!("a838e0a8", format!("{:x}", f_out));
}

#[test]
fn camellia_fiestel_fl_inv() {
    let x: [u8; 8] = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0];
    let y: [u8; 8] = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0];
    let f_out = CamelliaContext::f(u64::from_ne_bytes(x), u64::from_ne_bytes(y));
    assert_eq!("a838e0a8", format!("{:x}", f_out));
}

#[test]
fn round_keys_encrypt() {
    let keybits: u32 = 128;
    // let key = [4u8; 16];
    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    let expected_key: [u32; 68] = [
        0x1234567, 0x89abcdef, 0xfedcba98, 0x76543210, 0xae71c3d5, 0x5ba6bf1d, 0x169240a7,
        0x95f89256, 0xa2b3c4d5, 0xe6f7ff6e, 0x5d4c3b2a, 0x19080091, 0xe1eaadd3, 0x5f8e8b49,
        0x2053cafc, 0x492b5738, 0x56e9afc7, 0x45a49029, 0xe57e2495, 0xab9c70f5, 0x79bdffdb,
        0x97530eca, 0x86420024, 0x68acf135, 0xd7e3a2d2, 0x4814f2bf, 0x123456, 0x789abcde,
        0xd169240a, 0x795f8925, 0x6ae71c3d, 0x55ba6bf1, 0x97530eca, 0x86420024, 0x68acf135,
        0x79bdffdb, 0x1d950c84, 0x48d159, 0xe26af37b, 0xffb72ea6, 0xe57e2495, 0xab9c70f5,
        0x56e9afc7, 0x45a49029, 0x19080091, 0xa2b3c4d5, 0xe6f7ff6e, 0x5d4c3b2a, 0x492b5738,
        0xe1eaadd3, 0x5f8e8b49, 0x2053cafc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0,
    ];
    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(ENCRYPT);

    assert_eq!(cipher.rk, expected_key);
}

#[test]
fn round_keys_decrypt() {
    let keybits: u32 = 128;
    // let key = [4u8; 16];
    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    let expected_key: [u32; 68] = [
        0x492b5738, 0xe1eaadd3, 0x5f8e8b49, 0x2053cafc, 0xe6f7ff6e, 0x5d4c3b2a, 0x19080091,
        0xa2b3c4d5, 0x56e9afc7, 0x45a49029, 0xe57e2495, 0xab9c70f5, 0xe26af37b, 0xffb72ea6,
        0x1d950c84, 0x48d159, 0x68acf135, 0x79bdffdb, 0x97530eca, 0x86420024, 0x6ae71c3d,
        0x55ba6bf1, 0xd169240a, 0x795f8925, 0x123456, 0x789abcde, 0xd7e3a2d2, 0x4814f2bf,
        0x86420024, 0x68acf135, 0x79bdffdb, 0x97530eca, 0xe57e2495, 0xab9c70f5, 0x56e9afc7,
        0x45a49029, 0x2053cafc, 0x492b5738, 0xe1eaadd3, 0x5f8e8b49, 0x5d4c3b2a, 0x19080091,
        0xa2b3c4d5, 0xe6f7ff6e, 0x169240a7, 0x95f89256, 0xae71c3d5, 0x5ba6bf1d, 0x1234567,
        0x89abcdef, 0xfedcba98, 0x76543210, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0,
    ];
    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(DECRYPT);

    assert_eq!(cipher.rk, expected_key);
}

#[test]
fn encrypt_ecb_128() {
    let keybits: u32 = 128;
    // let key = [4u8; 16];
    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(ENCRYPT);

    let plain_text: [u8; 16] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10,
    ];

    let actual_ciphertext = cipher.mbedtls_camellia_crypt_ecb(plain_text);

    let expected_ciphertext: [u8; 16] = [
        0x67, 0x67, 0x31, 0x38, 0x54, 0x96, 0x69, 0x73, 0x8, 0x57, 0x6, 0x56, 0x48, 0xea, 0xbe,
        0x43,
    ];

    assert_eq!(actual_ciphertext, expected_ciphertext);
}

#[test]
fn decrypt_ecb_128() {
    let keybits: u32 = 128;
    // let key = [4u8; 16];
    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    let mut cipher = CamelliaContext::init(key, keybits);

    cipher.set_mode(DECRYPT);

    let cipher_text: [u8; 16] = [
        0x67, 0x67, 0x31, 0x38, 0x54, 0x96, 0x69, 0x73, 0x8, 0x57, 0x6, 0x56, 0x48, 0xea, 0xbe,
        0x43,
    ];

    let actual_plaintext = cipher.mbedtls_camellia_crypt_ecb(cipher_text);

    let expected_plaintext: [u8; 16] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10,
    ];

    assert_eq!(actual_plaintext, expected_plaintext);
}
#[test]
fn round_keys_encrypt_192() {
    let keybits: u32 = 192;
    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(ENCRYPT);

    let exp: [u32; 68] = [
        0x1234567, 0x89abcdef, 0xfedcba98, 0x76543210, 0x8f3afac1, 0xcc974396, 0xc098a0b7,
        0xe38b4df2, 0x9119a22a, 0xb33bfff7, 0x6ee65dd5, 0x4cc40008, 0x5109ae22, 0x714467b1,
        0xb5035d, 0x5f6983b3, 0xd115599d, 0xfffbb773, 0x2eeaa662, 0x4488c, 0x7325d0e5, 0xb026282d,
        0xf8e2d37c, 0xa3cebeb0, 0x79bdffdb, 0x97530eca, 0x86420024, 0x68acf135, 0x9c5119ec,
        0x402d40d7, 0x57da60ec, 0xd4426b88, 0xffedcba9, 0x87654321, 0x123456, 0x789abcde,
        0x7ffeeddc, 0xcbbaa998, 0x80011223, 0x34455667, 0x6c098a0b, 0x7e38b4df, 0x28f3afac,
        0x1cc97439, 0x97530eca, 0x86420024, 0x68acf135, 0x79bdffdb, 0x402d40d7, 0x57da60ec,
        0xd4426b88, 0x9c5119ec, 0x2eeaa662, 0x4488c, 0xd115599d, 0xfffbb773, 0x81aeafb4,
        0xc1d9a884, 0xd71138a2, 0x33d8805a, 0x19080091, 0xa2b3c4d5, 0xe6f7ff6e, 0x5d4c3b2a,
        0xa6f9479d, 0x7d60e64b, 0xa1cb604c, 0x505bf1c5,
    ];

    assert_eq!(cipher.rk, exp);
}

#[test]
fn round_keys_decrypt_192() {
    let keybits: u32 = 192;
    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(DECRYPT);
    let exp: [u32; 68] = [
        0xa6f9479d, 0x7d60e64b, 0xa1cb604c, 0x505bf1c5, 0xe6f7ff6e, 0x5d4c3b2a, 0x19080091,
        0xa2b3c4d5, 0xd71138a2, 0x33d8805a, 0x81aeafb4, 0xc1d9a884, 0xd115599d, 0xfffbb773,
        0x2eeaa662, 0x4488c, 0xd4426b88, 0x9c5119ec, 0x402d40d7, 0x57da60ec, 0x68acf135,
        0x79bdffdb, 0x97530eca, 0x86420024, 0x28f3afac, 0x1cc97439, 0x6c098a0b, 0x7e38b4df,
        0x80011223, 0x34455667, 0x7ffeeddc, 0xcbbaa998, 0x123456, 0x789abcde, 0xffedcba9,
        0x87654321, 0x57da60ec, 0xd4426b88, 0x9c5119ec, 0x402d40d7, 0x86420024, 0x68acf135,
        0x79bdffdb, 0x97530eca, 0xf8e2d37c, 0xa3cebeb0, 0x7325d0e5, 0xb026282d, 0x2eeaa662,
        0x4488c, 0xd115599d, 0xfffbb773, 0xb5035d, 0x5f6983b3, 0x5109ae22, 0x714467b1, 0x6ee65dd5,
        0x4cc40008, 0x9119a22a, 0xb33bfff7, 0xc098a0b7, 0xe38b4df2, 0x8f3afac1, 0xcc974396,
        0x1234567, 0x89abcdef, 0xfedcba98, 0x76543210,
    ];

    assert_eq!(cipher.rk, exp);
}
#[test]
fn encrypt_ecb_192() {
    let keybits: u32 = 192;
    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(ENCRYPT);

    let plain_text: [u8; 16] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10,
    ];

    let actual_ciphertext = cipher.mbedtls_camellia_crypt_ecb(plain_text);

    let expected_ciphertext: [u8; 16] = [
        0xb4, 0x99, 0x34, 0x01, 0xb3, 0xe9, 0x96, 0xf8, 0x4e, 0xe5, 0xce, 0xe7, 0xd7, 0x9b, 0x09,
        0xb9,
    ];

    assert_eq!(actual_ciphertext, expected_ciphertext);
}
#[test]
fn decrypt_ecb_192() {
    let keybits: u32 = 192;
    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00,
    ];
    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(DECRYPT);

    let ciphertext: [u8; 16] = [
        0xb4, 0x99, 0x34, 0x01, 0xb3, 0xe9, 0x96, 0xf8, 0x4e, 0xe5, 0xce, 0xe7, 0xd7, 0x9b, 0x09,
        0xb9,
    ];

    let expected_plain_text: [u8; 16] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10,
    ];

    let actual_plaintext = cipher.mbedtls_camellia_crypt_ecb(ciphertext);

    assert_eq!(actual_plaintext, expected_plain_text);
}
#[test]
fn encrypt_ecb_256() {
    let keybits: u32 = 256;

    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd,
        0xee, 0xff,
    ];

    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(ENCRYPT);

    let plain_text: [u8; 16] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10,
    ];

    let actual_ciphertext = cipher.mbedtls_camellia_crypt_ecb(plain_text);

    let expected_ciphertext: [u8; 16] = [
        0x9a, 0xcc, 0x23, 0x7d, 0xff, 0x16, 0xd7, 0x6c, 0x20, 0xef, 0x7c, 0x91, 0x9e, 0x3a, 0x75,
        0x09,
    ];

    assert_eq!(actual_ciphertext, expected_ciphertext);
}
#[test]
fn decrypt_ecb_256() {
    let keybits: u32 = 256;

    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd,
        0xee, 0xff,
    ];

    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(DECRYPT);

    let ciphertext: [u8; 16] = [
        0x9a, 0xcc, 0x23, 0x7d, 0xff, 0x16, 0xd7, 0x6c, 0x20, 0xef, 0x7c, 0x91, 0x9e, 0x3a, 0x75,
        0x09,
    ];

    let expected_plain_text: [u8; 16] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10,
    ];

    let actual_plaintext = cipher.mbedtls_camellia_crypt_ecb(ciphertext);

    assert_eq!(actual_plaintext, expected_plain_text);
}

#[test]
fn round_keys_encrypt_256() {
    let keybits: u32 = 256;

    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd,
        0xee, 0xff,
    ];

    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(ENCRYPT);
    let exp: [u32; 68] = [
        0x1234567, 0x89abcdef, 0xfedcba98, 0x76543210, 0x38152142, 0x80a4d3c0, 0x1848fd9a,
        0xc7b1fe60, 0x9119a22a, 0xb33bc44c, 0xd55de66e, 0xf77f8008, 0xdad8236f, 0x83fd64dd,
        0xc8a5bf8c, 0x9bf70be8, 0xd115599d, 0xe2266aae, 0xf3377bbf, 0xc004488c, 0xa02934f0,
        0x6123f66, 0xb1ec7f98, 0xe054850, 0x79bdffdb, 0x97530eca, 0x86420024, 0x68acf135,
        0xe0ff5937, 0x72296fe3, 0x26fdc2fa, 0x36b608db, 0xffedcba9, 0x87654321, 0x123456,
        0x789abcde, 0x78899aab, 0xbccddeef, 0xf0011223, 0x34455667, 0x1848fd9, 0xac7b1fe6,
        0x3815214, 0x280a4d3c, 0x97530eca, 0x86420024, 0x68acf135, 0x79bdffdb, 0x72296fe3,
        0x26fdc2fa, 0x36b608db, 0xe0ff5937, 0xf3377bbf, 0xc004488c, 0xd115599d, 0xe2266aae,
        0xdfc64dfb, 0x85f46d6c, 0x11b7c1fe, 0xb26ee452, 0x19080091, 0xa2b3c4d5, 0xe6f7ff6e,
        0x5d4c3b2a, 0xff301c0a, 0x90a14052, 0x69e00c24, 0x7ecd63d8,
    ];

    assert_eq!(cipher.rk, exp);
}

#[test]
fn round_keys_decrypt_256() {
    let keybits: u32 = 256;

    let key: [u8; 32] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32,
        0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd,
        0xee, 0xff,
    ];

    let mut cipher = CamelliaContext::init(key, keybits);
    cipher.set_mode(DECRYPT);
    let exp: [u32; 68] = [
        0xff301c0a, 0x90a14052, 0x69e00c24, 0x7ecd63d8, 0xe6f7ff6e, 0x5d4c3b2a, 0x19080091,
        0xa2b3c4d5, 0x11b7c1fe, 0xb26ee452, 0xdfc64dfb, 0x85f46d6c, 0xd115599d, 0xe2266aae,
        0xf3377bbf, 0xc004488c, 0x36b608db, 0xe0ff5937, 0x72296fe3, 0x26fdc2fa, 0x68acf135,
        0x79bdffdb, 0x97530eca, 0x86420024, 0x3815214, 0x280a4d3c, 0x1848fd9, 0xac7b1fe6,
        0xf0011223, 0x34455667, 0x78899aab, 0xbccddeef, 0x123456, 0x789abcde, 0xffedcba9,
        0x87654321, 0x26fdc2fa, 0x36b608db, 0xe0ff5937, 0x72296fe3, 0x86420024, 0x68acf135,
        0x79bdffdb, 0x97530eca, 0xb1ec7f98, 0xe054850, 0xa02934f0, 0x6123f66, 0xf3377bbf,
        0xc004488c, 0xd115599d, 0xe2266aae, 0xc8a5bf8c, 0x9bf70be8, 0xdad8236f, 0x83fd64dd,
        0xd55de66e, 0xf77f8008, 0x9119a22a, 0xb33bc44c, 0x1848fd9a, 0xc7b1fe60, 0x38152142,
        0x80a4d3c0, 0x1234567, 0x89abcdef, 0xfedcba98, 0x76543210,
    ];

    assert_eq!(cipher.rk, exp);
}
